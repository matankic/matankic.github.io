<!doctype html>
<html lang="en">
    <head>
        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;500;600;700&display=swap&family=Noto+Sans:wght@400;500;600&display=swap"
            rel="stylesheet"
        />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Learning to See Inside Opaque Liquid Containers using Speckle
            Vibrometry
        </title>
        <style>
            body {
                font-family: "Helvetica", Arial, sans-serif;
                line-height: 1.5;
                color: #4a4a4a;
                font-size: 1em;
                font-weight: 400;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                margin: 0;
                padding: 0;
            }
            .sv-wrap {
                max-width: 64rem;
                margin: 70px 80px 50px 80px;
            }

            .sv-card {
                position: relative;
                overflow-x: auto;
                border: 1px solid #e5e7eb;
                border-radius: 10px;
                box-shadow: 0 12px 24px rgba(0, 0, 0, 0.06);
            }
            .sv-table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
            }
            .sv-table thead th {
                text-transform: uppercase;
                font-size: 1rem;
                letter-spacing: 0.03em;
                background: #f3f4f6;
                color: #4a4a4a;
                padding: 12px 16px;
                text-align: center;
                border-bottom: 1px solid #d1d5db;
                border-right: 1px solid #d1d5db;
            }
            .sv-table thead th.sv-left {
                text-align: center;
            }
            .sv-table tbody th,
            .sv-table tbody td {
                padding: 14px 16px;
                border-bottom: 1px solid #e5e7eb;
                border-right: 1px solid #d1d5db;
            }
            .sv-table tbody th {
                white-space: nowrap;
                text-align: left;
                color: #4a4a4a;
                font-weight: 600;
            }
            .sv-table tr:hover {
                background: #f9fafb;
                transition: background-color 0.2s;
            }
            .sv-table th:last-child,
            .sv-table td:last-child {
                border-right: none;
            }
            .sv-table tbody tr:last-child th,
            .sv-table tbody tr:last-child td {
                border-bottom: none;
            }
            .sv-caption {
                text-align: center;
                color: #6b7280;
                font-size: 0.9rem;
                margin-top: 0.75rem;
            }
            .below-figure-cta {
                margin-top: 1rem;
                text-align: center;
            }
            .cta-link {
                display: inline-flex;
                align-items: center;
                gap: 0.25rem;
                margin: -10px 0px 10px 0px;
                padding: 0.5rem 0.9rem;
                border-radius: 0.5rem;
                text-decoration: none;
                border: 1px solid #ddd;
                color: #209cee;
                font-weight: 600;
            }
            .cta-link:focus {
                outline: 2px solid;
                outline-offset: 2px;
            }
            .cta-link:hover {
                text-decoration: underline;
            }

            .container {
                max-width: 960px;
                margin: 0 auto;
                padding: 40px 20px;
            }

            .header {
                text-align: center;
                margin-bottom: 40px;
            }

            .title {
                font-family:
                    helvetica,
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    sans-serif;
                font-size: 3em;
                font-weight: bold;
                color: #4a4a4a;
            }

            .subtitle {
                font-family:
                    helvetica,
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    sans-serif;
                font-size: 1.3em;
                font-weight: bold;
                color: #4a4a4a;
                margin-top: 1.2em;
                margin-bottom: -0.2em;
            }

            .authors {
                font-size: 1.5em;
            }

            .authors a {
                color: #209cee;
                text-decoration: none;
            }

            .authors a:hover {
                text-decoration: underline;
            }

            .affiliation {
                font-size: 1.5em;
            }

            .conference {
                font-size: 1.7em;
                margin-bottom: 25px;
            }

            .publication-links {
                display: flex;
                justify-content: center;
                gap: 10px;
                flex-wrap: wrap;
                margin-bottom: 30px;
            }

            .link-block {
                display: inline-block;
            }

            .external-link {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 10px 16px;
                background: #363636;
                color: white;
                text-decoration: none;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                transition: background-color 0.2s ease;
                border: none;
                cursor: pointer;
            }

            .external-link:hover {
                background: #4a4a4a;
                color: white;
            }

            .external-link .icon {
                width: 22px;
                height: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .external-link .icon svg {
                width: 25px;
                height: 18px;
                fill: currentColor;
            }

            .external-link-model {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 10px 16px;
                background: #363636;
                color: white;
                text-decoration: none;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                transition: background-color 0.2s ease;
                border: none;
                cursor: pointer;
            }

            .external-link-model:hover {
                background: #4a4a4a;
                color: white;
            }

            .external-link-model .icon {
                width: 22px;
                height: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .external-link-model .icon svg {
                width: 25px;
                height: 18px;
                fill: currentColor;
            }

            .teaser-image {
                text-align: center;
                margin: 40px 0;
            }

            .teaser-image img {
                max-width: 55%;
                height: auto;
                border-radius: 8px;
            }

            .fill-level-image {
                position: relative;
                max-width: 100%;
                width: 75%;
                margin: auto;
            }

            .fill-level-image img {
                display: block;
                width: 100%;
                height: auto;
            }

            .system-image {
                position: relative;
                max-width: 100%;
                width: 80%;
                margin: auto;
            }

            .system-image img {
                display: block;
                width: 100%;
                height: auto;
            }

            .section {
                margin-bottom: 50px;
            }

            .section h2 {
                font-size: 1.8em;
                font-weight: normal;
                margin-bottom: 20px;
                color: #333;
            }

            .publication-title {
                font-size: 1.1em;
                font-weight: 500;
                margin-bottom: 10px;
                color: #333;
            }

            .buttons {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 15px;
            }

            .btn {
                padding: 8px 16px;
                background: #333;
                color: white;
                text-decoration: none;
                border-radius: 4px;
                font-size: 0.9em;
                transition: background-color 0.2s;
            }

            .btn:hover {
                background: #555;
            }

            .abstract-box {
                background: #f5f5f5;
                border-radius: 8px;
                padding: 20px;
                margin: 20px 0;
                font-size: 1em;
                line-height: 1.7;
                text-align: justify;
            }

            .full-width-image {
                width: 100%;
                max-width: 100%;
                display: block;
            }

            .method-image {
                text-align: center;
                margin: 30px 0;
            }

            .method-image img {
                max-width: 100%;
                height: auto;
            }

            .demo-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin: 30px 0;
            }

            .demo-item {
                background: #f5f5f5;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
            }

            .demo-placeholder {
                width: 100%;
                height: 150px;
                background: #e9ecef;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 15px;
                color: #666;
                font-size: 0.9em;
            }

            .demo-caption {
                font-size: 0.9em;
                color: #666;
                line-height: 1.4;
            }

            p {
                font-size: 1em;
                text-align: justify;
                margin-bottom: 15px;
                line-height: 1.6;
            }

            .bibtex-container {
                position: relative;
            }

            .copy-button {
                position: absolute;
                top: 15px;
                right: 15px;
                background: #333;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8em;
                transition: background-color 0.2s;
            }

            .copy-button:hover {
                background: #555;
            }

            .copy-button.copied {
                background: #28a745;
            }

            .pushable {
                background: hsl(0deg 0% 60%);
                border-radius: 50px;
                border: none;
                padding: 0;
                cursor: pointer;
                outline-offset: 4px;
                position: absolute;
                bottom: -55px;
                transform: translateX(-50%);
            }

            .front {
                display: block;
                padding: 3px 16px;
                border-radius: 50px;
                font-size: 1.2rem;
                background: hsl(0deg 0% 90%);
                color: hsl(0deg 0% 50%);
                transform: translateY(-5px);
                box-shadow:
                    0 8px 8px rgba(0, 0, 0, 0.12),
                    0 1px 2px rgba(0, 0, 0, 0.06);
                transition:
                    transform 80ms ease,
                    box-shadow 80ms ease;
            }

            .pushable:active .front {
                transform: translateY(-2px);
                box-shadow:
                    0 1px 3px rgba(0, 0, 0, 0.1),
                    0 1px 1px rgba(0, 0, 0, 0.06);
            }

            .pushable.playing .front {
                transform: translateY(-2px);
                box-shadow:
                    0 1px 3px rgba(0, 0, 0, 0.1),
                    0 1px 1px rgba(0, 0, 0, 0.06);
            }

            /* Rotary volume control */
            .controller-row {
                display: flex;
                gap: 28px;
                align-items: center;
                justify-content: center;
                flex-wrap: wrap;
            }

            .volume-control {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
                margin-left: 0; /* centered layout */
                user-select: none;
            }

            .rotary-wrapper {
                position: relative;
                width: 120px;
                height: 120px;
                cursor: default;
            }

            .rotary-knob {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 92px;
                height: 92px;
                transform: translate(-50%, -50%); /* keep lighting static */
                border-radius: 50%;
                background: radial-gradient(
                    65% 65% at 30% 30%,
                    #1a1a1a 0%,
                    #0f0f0f 60%,
                    #000 100%
                );
                box-shadow:
                    inset 0 2px 6px rgba(255, 255, 255, 0.06),
                    inset 0 -8px 16px rgba(0, 0, 0, 0.8),
                    0 6px 18px rgba(0, 0, 0, 0.3);
                border: 1px solid #0c0c0c;
            }

            .rotary-wrapper:hover {
                cursor: pointer;
            }
            .rotary-wrapper.dragging {
                cursor: grabbing;
            }
            .rotary-wrapper:active {
                cursor: grabbing;
            }

            .rotary-knob::before {
                content: "";
                position: absolute;
                inset: 10px;
                border-radius: 50%;
                background: radial-gradient(
                    60% 60% at 30% 30%,
                    #222 0%,
                    #111 60%,
                    #0a0a0a 100%
                );
            }

            .rotary-angle {
                position: absolute;
                inset: 0;
            }

            .rotary-indicator {
                position: absolute;
                top: 14px;
                left: 50%;
                width: 3px;
                height: 24px;
                transform: translateX(-50%);
                background: linear-gradient(180deg, #e8e8e8 0%, #cfcfcf 100%);
                border-radius: 2px;
                box-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
            }

            .ticks {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 120px;
                height: 120px;
                transform: translate(-50%, -50%);
                pointer-events: none;
            }

            .tick {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 3px;
                height: 12px;
                background: #d9d9d9; /* light gray for not reached */
                border-radius: 2px;
                opacity: 0.9;
                box-shadow: 0 0 0.5px rgba(255, 255, 255, 0.15);
            }

            .tick.active {
                background: #5e5e5e; /* darker gray for reached */
            }

            .volume-readout {
                display: flex;
                flex-direction: column;
                gap: 6px;
                align-items: center;
            }

            .volume-readout .title {
                font-size: 0.95em;
                font-weight: 600;
                margin: 0;
                color: #333;
                text-align: center;
            }

            .volume-label {
                display: inline-block;
                min-width: 44px;
                padding: 2px 8px;
                border-radius: 12px;
                background: #111;
                color: #f0f0f0;
                font-variant-numeric: tabular-nums;
                text-align: center;
                font-weight: 600;
                letter-spacing: 0.5px;
                cursor: pointer;
                outline: none;
            }

            .volume-label:hover {
                filter: brightness(1.08);
            }
            .volume-label:focus {
                box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.35);
            }

            /* Interactive hint: hand-grip icon following an arc, hidden on interaction */
            .hint-hand {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 34px;
                height: 34px;
                opacity: 0; /* start hidden; fade in for demo */
                transition: opacity 300ms ease;
                pointer-events: none;
                transform: translate(-50%, -50%);
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
            }

            .hint-hand.visible {
                opacity: 0.95;
            }

            /* Signal panel */
            .signal-panel {
                flex: 1 1 480px; /* restore previous preferred size */
                min-width: 380px;
                max-width: 620px;
            }

            .snr-figure-container {
                text-align: center;
                margin: 0;
                width: 100%;
                position: relative;
            }

            .snr-figure {
                max-width: 100%;
                height: 250px;
                border-radius: 8px;
            }

            .signal-title {
                font-size: 0.95em;
                font-weight: 600;
                margin: 0 0 6px;
                color: #333;
            }

            .signal-card {
                background: #ffffff;
                border: 1px solid #e5e5e5;
                border-radius: 10px;
                padding: 12px 12px 8px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.06);
            }

            .signal-canvas-wrap {
                position: relative;
                width: 100%;
                height: 160px;
                border-radius: 8px;
                overflow: hidden;
                background: linear-gradient(180deg, #fafafa 0%, #f7f7f7 100%);
                border: 1px solid #ececec;
            }

            /* Simple file:// friendly SVG scroller */
            .signal-viewport {
                position: relative;
                width: 100%;
                height: 160px;
                overflow: hidden;
                border-radius: 8px;
            }
            .signal-strip {
                position: absolute;
                inset: 0;
                width: 200%;
                height: 100%;
                display: flex;
                animation: signalScroll var(--scroll-duration, 8s) linear
                    infinite;
            }
            .signal-frame {
                width: 50%;
                height: 100%;
            }
            .signal-img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }
            @keyframes signalScroll {
                from {
                    transform: translateX(0);
                }
                to {
                    transform: translateX(-50%);
                }
            }

            .signal-meta {
                margin-top: 8px;
                font-size: 0.9em;
                color: #555;
            }

            .signal-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 12px;
                margin-top: 8px;
            }

            .results-wrap {
                position: relative;
                max-width: 1400px; /* optional */
                margin: 70px 100px 10px 300px;
            }
            .results-base {
                width: 100%;
                display: block;
            }

            /* Results overlay labels */
            .results-overlay {
                position: absolute;
                inset: 0;
                font-weight: 600;
            }
            .results-overlay .label {
                position: absolute;
                padding: 2px 6px;
                font-size: 1.2rem;
            }
            .results-overlay .label-top {
                top: 0%;
                transform: translate(-50%, -120%);
            }
            .results-overlay .label-left {
                left: 0%;
                transform: translate(-110%, -50%);
            }

            .results-overlay .err-card {
                position: absolute;
                left: 0%;
                transform: translate(-180%, -50%);
                padding-top: 2px;
                padding-bottom: 2px;
                font-size: 1rem;
                border-radius: 6px;
                color: #fff;
                font-weight: 600;
                background: linear-gradient(
                    135deg,
                    #f43f5e,
                    #b91c1c
                ); /* red gradient */
                white-space: nowrap;
                width: 90px; /* fixed width */
                text-align: center; /* center the text */
                box-sizing: border-box;
            }

            .membrane-wrap {
                --overlay-top: 16%;
                --overlay-bottom: 14%;
                --overlay-left: 22%;
                --overlay-right: 19%;
                position: relative;
                max-width: 1400px; /* optional */
                margin: 20px 50px 70px 90px;
            }
            .membrane-base {
                width: 90%;
                display: block;
            }

            .membrane-overlay {
                position: absolute;
                top: var(--overlay-top);
                bottom: var(--overlay-bottom);
                left: var(--overlay-left);
                right: var(--overlay-right);
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 6.5%;
                align-items: center;
            }

            .mode {
                margin: 0;
                text-align: center;
            }
            .mode img {
                width: 77%;
                object-fit: contain; /* keeps GIFs inside the placeholder shapes */
                display: block;
            }

            .mode video {
                width: 77%;
                object-fit: contain;
                display: block;
            }

            .mode figcaption {
                margin-top: 0.3rem;
                margin-left: -1rem;
                color: #333;
                text-align: center;
                font-weight: 600;
                font-size: 1rem; /* slightly bigger */
            }

            @media (max-width: 768px) {
                .membrane-overlay {
                    position: static;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 1rem;
                    pointer-events: auto;
                }

                .mode img {
                    height: auto;
                }

                .container {
                    padding: 20px 15px;
                }

                .title {
                    font-size: 1.8em;
                }

                .authors a {
                    margin-right: 10px;
                }

                .demo-grid {
                    grid-template-columns: 1fr;
                }

                .publication-links {
                    gap: 8px;
                }

                .external-link {
                    padding: 8px 12px;
                    font-size: 0.85em;
                }

                .external-link-model {
                    padding: 8px 12px;
                    font-size: 0.85em;
                }

                .full-width-image {
                    width: 120%;
                    margin-left: -10%;
                    margin-right: -10%;
                }
            }

            .gif-overlay {
                position: absolute;
                top: 47px;
                left: calc(50% + 104px);
                transform: translateX(-50%);
                z-index: 10;
            }

            .gif-profile {
                width: 123px;
                height: 123px;
                border-radius: 50%;
                border: 3px solid white;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                object-fit: cover;
            }

            .gif-profile.active {
                border-color: #209cee;
                box-shadow: 0 0 15px rgba(32, 156, 238, 0.5);
            }

            /* Vertical slider (blue accent, discrete 6 levels) */
            .v-slider-section {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin: 16px 0 26px;
            }

            .dual-panels {
                display: grid;
                grid-template-columns: max-content max-content; /* no stretching */
                gap: 60px;
                width: fit-content; /* shrink-wrap to content */
                margin: 0 auto; /* center in the page */
                align-items: end; /* bottom-align both cards */
                justify-items: center;
            }

            .v-slider-row {
                display: flex;
                align-items: flex-end; /* align bottoms of slider and image */
                justify-content: center;
                gap: 32px; /* further to the right */
                width: 100%;
            }

            .v-slider-col {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .v-preview-col {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-left: -20px;
            }

            .v-slider-label {
                font-size: 0.95em;
                font-weight: 600;
                color: #333;
                margin-top: 15px; /* extra space from slider */
            }

            .v-slider {
                position: relative;
                width: 44px;
                height: 200px;
                user-select: none;
                touch-action: none;
                outline: none;
                transform: translatey(10%);
            }

            .v-slider-section {
                min-width: 260px; /* keep the wine card wide enough */
                padding: 28px;
                background: #fcfcfc;
                border: 1px solid#e8e8e8;
                border-radius: 10px;
                display: flex;
                flex-direction: column; /* enable bottom alignment inside */
            }

            /* push the interactive row to the bottom in BOTH cards */
            .v-slider-section .v-slider-row {
                margin-top: auto;
            }

            .v-track {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 10px;
                bottom: 10px;
                width: 8px;
                border-radius: 6px;
                background: linear-gradient(180deg, #e9f0ff 0%, #d8e5ff 100%);
                box-shadow: inset 0 0 0 1px rgba(13, 110, 253, 0.12);
                z-index: 0;
            }

            .v-water {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px; /* align with track bottom */
                width: 8px;
                height: 0px; /* will be updated in JS */
                border-radius: 6px;
                background: linear-gradient(180deg, #6fb6ff 0%, #0d6efd 70%);
                box-shadow:
                    inset 0 -2px 6px rgba(0, 0, 0, 0.12),
                    0 0 0 1px rgba(13, 110, 253, 0.18);
                transition: height 140ms ease;
                z-index: 1;
            }

            .v-ticks {
                position: absolute;
                inset: 15px 0 10px 0;
                z-index: 2;
                pointer-events: none;
            }
            .v-tick {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                width: 5px;
                height: 5px;
                border-radius: 50%;
                background: rgba(13, 110, 253, 0.3);
            }

            .v-thumb {
                position: absolute;
                left: 50%;
                transform: translate(-50%, -20%);
                bottom: 0%;
                width: 22px;
                height: 22px;
                border-radius: 50%;
                background: #0d6efd;
                border: 3px solid #ffffff;
                box-shadow: 0 4px 10px rgba(13, 110, 253, 0.35);
                cursor: grab;
                transition: bottom 140ms ease;
                z-index: 3;
            }
            .v-slider.dragging .v-thumb {
                cursor: grabbing;
                transition: none;
            }
            .v-slider.dragging .v-water {
                transition: none;
            }

            .right-column {
                display: grid;
                grid-template-rows: auto 1fr;
                height: 100%;
            }

            .global-source-wrap {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 20px; /* spacing before the card */
            }

            .global-source-wrap .title {
                font-size: 0.95em;
                font-weight: 600;
                color: #333;
            }

            /* Vertical slider hint hand */
            .v-hint-hand {
                position: absolute;
                left: calc(50% - 40px); /* shift slightly left of the bar */
                transform: none;
                bottom: 10px; /* start at track bottom */
                width: 30px;
                height: 30px;
                opacity: 0;
                transition: opacity 300ms ease;
                pointer-events: none;
                z-index: 4;
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
            }
            .v-hint-hand.visible {
                opacity: 0.95;
            }

            .v-value {
                display: inline-block;
                min-width: 48px;
                text-align: center;
                font-weight: 600;
                color: #0d6efd;
                background: #eef4ff;
                border: 1px solid rgba(13, 110, 253, 0.25);
                border-radius: 999px;
                padding: 1px 4px;
                font-variant-numeric: tabular-nums;
            }

            .v-preview-img {
                width: 100px;
                height: auto;
                display: block;
            }

            /* Truncate 5px from the right of coke can images */
            #vPreviewCoke {
                margin-right: -12px;
                overflow: hidden;
            }

            /* Inline play button under preview (reuse pushable styles, override positioning) */
            .pushable-inline {
                position: relative;
                bottom: auto;
                transform: none;
                outline-offset: 0;
                margin-top: 10px;
                left: -10px; /* 10px to the left */
                top: 5px; /* 3px down */
            }

            /* Fine-tune coke can play button position */
            #vPlayBtnCoke {
                left: -12px; /* 2px further left than default */
            }

            /* Source selector buttons */
            .source-group {
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: center;
            }
            .source-btn {
                border: 1px solid #d9d9d9;
                background: #f7f7f7;
                color: #333;
                border-radius: 999px;
                padding: 6px 12px;
                font-size: 0.85em;
                cursor: pointer;
                transition: all 160ms ease;
            }
            .source-btn:hover {
                filter: brightness(0.98);
            }
            .source-btn.active {
                border-color: #0d6efd;
                color: #0d6efd;
                background: #eaf2ff;
            }
            .source-btn.chirp.active {
                border-color: #2e7d32;
                color: #2e7d32;
                background: #e9f6ea;
            }
            .source-btn.ambient.active {
                border-color: #c62828;
                color: #c62828;
                background: #ffe9e9;
            }

            /* Global source selector placement */
            .global-source-wrap {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                margin: 10px 0 6px;
            }

            /* Left panel (milk) wine-purple accent overrides */
            #vSliderL .v-track {
                background: linear-gradient(180deg, #fae7ef 0%, #f3cfdb 100%);
                box-shadow: inset 0 0 0 1px rgba(123, 30, 61, 0.22);
            }
            #vWaterL {
                background: linear-gradient(180deg, #cc4c77 0%, #7b1e3d 70%);
                box-shadow:
                    inset 0 -2px 6px rgba(0, 0, 0, 0.12),
                    0 0 0 1px rgba(123, 30, 61, 0.28);
            }
            #vThumbL {
                background: #7b1e3d;
                box-shadow: 0 4px 10px rgba(123, 30, 61, 0.38);
            }
            #vTicksL .v-tick {
                background: rgba(123, 30, 61, 0.5);
            }
            #vValueL {
                color: #7b1e3d;
                background: #fae7ef;
                border-color: rgba(123, 30, 61, 0.35);
            }
        </style>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                (function colorizeErrorCards() {
                    const MIN = 1,
                        MAX = 20;
                    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
                    const lerp = (a, b, t) => a + (b - a) * t;

                    const g = { h: 150, s: 70, l: 40 }; // green
                    const r = { h: 0, s: 80, l: 45 }; // red

                    document.querySelectorAll(".err-card").forEach((el) => {
                        const m = el.textContent.match(/(\d+(\.\d+)?)%/);
                        if (!m) return;
                        const val = clamp(parseFloat(m[1]), MIN, MAX);
                        const t = (val - MIN) / (MAX - MIN);

                        const h = lerp(g.h, r.h, t);
                        const s = lerp(g.s, r.s, t);
                        const l = lerp(g.l, r.l, t);
                        const h2 = h - 10,
                            s2 = Math.min(100, s + 5),
                            l2 = Math.max(0, l - 8);

                        el.style.background = `linear-gradient(135deg,hsl(${h} ${s}% ${l}%),hsl(${h2} ${s2}% ${l2}%))`;
                    });
                })();
            });
            function toggleAudio(audioId, button) {
                const audio = document.getElementById(audioId);

                if (audio.paused) {
                    // Start playing
                    audio.play();
                    button.classList.add("playing");

                    // Remove the class when audio ends
                    audio.addEventListener(
                        "ended",
                        function () {
                            button.classList.remove("playing");
                        },
                        { once: true },
                    );
                } else {
                    // Stop playing
                    audio.pause();
                    audio.currentTime = 0;
                    button.classList.remove("playing");
                }
            }

            function copyBibTeX(button) {
                const bibtexText =
                    document.getElementById("bibtex-text").textContent;

                // Use the modern Clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard
                        .writeText(bibtexText)
                        .then(function () {
                            // Show success feedback
                            const originalText = button.textContent;
                            button.textContent = "Copied!";
                            button.classList.add("copied");

                            setTimeout(function () {
                                button.textContent = originalText;
                                button.classList.remove("copied");
                            }, 2000);
                        })
                        .catch(function (err) {
                            console.error("Failed to copy text: ", err);
                            fallbackCopy(bibtexText, button);
                        });
                } else {
                    // Fallback for older browsers or non-secure contexts
                    fallbackCopy(bibtexText, button);
                }
            }

            function fallbackCopy(text, button) {
                // Create a temporary textarea element
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);

                textArea.focus();
                textArea.select();

                try {
                    document.execCommand("copy");
                    // Show success feedback
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.classList.add("copied");

                    setTimeout(function () {
                        button.textContent = originalText;
                        button.classList.remove("copied");
                    }, 2000);
                } catch (err) {
                    console.error("Fallback copy failed: ", err);
                    button.textContent = "Copy failed";
                    setTimeout(function () {
                        button.textContent = "Copy";
                    }, 2000);
                } finally {
                    document.body.removeChild(textArea);
                }
            }

            // (volume knob removed)
            document.addEventListener("DOMContentLoaded", function () {
                const wrapper = null; // removed
                if (false) return;

                const knob = wrapper.querySelector(".rotary-knob");
                const angleLayer = knob.querySelector(".rotary-angle");
                const ticksContainer = wrapper.querySelector(".ticks");
                const labelEl = document.getElementById("volumeLabel");
                const hintHand = document.getElementById("hintHand");
                let hintLoopActive = true; // keep showing hint until user changes volume
                const hintDelayMs = 3000; // wait 3s before starting next hint loop

                // -------- Background sine tone (422 Hz) --------
                let sineInitialized = false;
                let audioCtx = null;
                let sineGain = null;
                let oscillator = null;

                function initSineIfNeeded() {
                    if (sineInitialized) {
                        if (audioCtx?.state === "suspended") {
                            audioCtx.resume?.();
                        }
                        return;
                    }
                    try {
                        const Ctx =
                            window.AudioContext || window.webkitAudioContext;
                        audioCtx = new Ctx();
                        sineGain = audioCtx.createGain();
                        sineGain.gain.value = 0.0; // start muted
                        oscillator = audioCtx.createOscillator();
                        oscillator.type = "sine";
                        oscillator.frequency.value = 422; // Hz
                        oscillator
                            .connect(sineGain)
                            .connect(audioCtx.destination);
                        oscillator.start();
                        sineInitialized = true;
                    } catch (e) {
                        // no-op if Web Audio not available
                    }
                }

                function setSineVolume(volume01) {
                    if (!sineInitialized || !sineGain) return;
                    const v = Math.max(0, Math.min(1, volume01));
                    try {
                        const now = audioCtx.currentTime || 0;
                        // Smooth ramp for nicer UX
                        sineGain.gain.setTargetAtTime(v, now, 0.05);
                    } catch (e) {
                        sineGain.gain.value = v;
                    }
                }

                const MIN_ANGLE = -120; // degrees
                const MAX_ANGLE = 120; // degrees
                const NUM_LEVELS = 12; // 0..11
                const STEP_DEG = (MAX_ANGLE - MIN_ANGLE) / (NUM_LEVELS - 1);

                // Remove signal state (not used now)

                // Generate ticks on a not-full circle arc
                for (let i = 0; i < NUM_LEVELS; i++) {
                    const angle = MIN_ANGLE + i * STEP_DEG;
                    const tick = document.createElement("div");
                    tick.className = "tick";
                    tick.style.transform = `translate(-50%, -50%) rotate(${angle}deg) translate(0, -56px)`;
                    ticksContainer.appendChild(tick);
                }

                function setLevel(level) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    const angle = MIN_ANGLE + clamped * STEP_DEG;
                    // Rotate only the indicator layer; keep knob lighting static
                    angleLayer.style.transform = `rotate(${angle}deg)`;

                    // Update ticks highlight
                    const ticks = ticksContainer.querySelectorAll(".tick");
                    ticks.forEach((t, idx) => {
                        if (idx <= clamped) t.classList.add("active");
                        else t.classList.remove("active");
                    });

                    // Update label: OFF, 4 dB, 8 dB, ...
                    const db = clamped * 4;
                    labelEl.textContent = clamped === 0 ? "OFF" : `${db} dB`;

                    // Set global audio volume
                    const baseVolume = clamped / (NUM_LEVELS - 1);
                    const adjustedVolume = baseVolume; // full range 0.0 â†’ 1.0
                    // Apply master volume to all audios except those explicitly excluded
                    document
                        .querySelectorAll("audio:not(.ignore-global-volume)")
                        .forEach((a) => {
                            try {
                                a.volume = adjustedVolume;
                            } catch (e) {}
                        });
                    // Also update background sine tone volume
                    try {
                        setSineVolume(adjustedVolume);
                    } catch (e) {}

                    // (gif removed)

                    // a11y
                    wrapper.setAttribute("aria-valuenow", String(clamped));
                    wrapper.setAttribute(
                        "aria-valuetext",
                        clamped === 0 ? "OFF" : `${db} dB`,
                    );

                    wrapper.dataset.level = String(clamped);

                    // Sync SVG panel to level
                    updateSignalFromLevel(clamped);
                }

                function angleToLevel(angleDeg) {
                    const clampedAngle = Math.max(
                        MIN_ANGLE,
                        Math.min(MAX_ANGLE, angleDeg),
                    );
                    const raw = (clampedAngle - MIN_ANGLE) / STEP_DEG;
                    // Make the first bin (OFF) slightly larger for easier access
                    // If we're within half-a-step of MIN_ANGLE, snap to 0
                    if (clampedAngle <= MIN_ANGLE + STEP_DEG * 0.6) return 0;
                    return Math.round(raw);
                }

                function clientToAngle(clientX, clientY) {
                    const rect = wrapper.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dx = clientX - cx;
                    const dy = clientY - cy;
                    // Base angle: 0 at +X; shift so 12 o'clock is 0 deg
                    let deg = (Math.atan2(dy, dx) * 180) / Math.PI + 90;
                    // Normalize to [-180, 180] so negative angles are reachable (left side)
                    if (deg > 180) deg -= 360;
                    if (deg < -180) deg += 360;
                    return deg;
                }

                let dragging = false;
                let pointerDownInside = false;

                function disableHint() {
                    hintLoopActive = false;
                    if (hintRunning && hintRafId)
                        cancelAnimationFrame(hintRafId);
                    hintRunning = false;
                    hintHand?.classList.remove("visible");
                }

                function onPointerDown(e) {
                    dragging = true;
                    pointerDownInside = true;
                    wrapper.classList.add("dragging");
                    wrapper.setPointerCapture?.(e.pointerId);
                    const angle = clientToAngle(e.clientX, e.clientY);
                    // If user starts at far-left above OFF threshold, snap to OFF
                    const tentative = angleToLevel(angle);
                    if (tentative === 1 && angle < MIN_ANGLE + STEP_DEG * 0.3) {
                        setLevel(0);
                    } else {
                        setLevel(tentative);
                    }
                    e.preventDefault();
                    // Init background sine on first interaction (user gesture)
                    try {
                        initSineIfNeeded();
                    } catch (e) {}
                    // Stop hint loop on first interaction
                    disableHint();
                }

                function onPointerMove(e) {
                    if (!dragging) return;
                    const angle = clientToAngle(e.clientX, e.clientY);
                    setLevel(angleToLevel(angle));
                }

                function onPointerUp(e) {
                    dragging = false;
                    pointerDownInside = false;
                    wrapper.classList.remove("dragging");
                    wrapper.releasePointerCapture?.(e.pointerId);
                }

                // (removed knob listeners)

                // Keyboard support
                wrapper.addEventListener("keydown", (e) => {
                    const current = Number(wrapper.dataset.level || "0");
                    if (e.key === "ArrowRight" || e.key === "ArrowUp") {
                        setLevel(current + 1);
                        e.preventDefault();
                    } else if (e.key === "ArrowLeft" || e.key === "ArrowDown") {
                        setLevel(current - 1);
                        e.preventDefault();
                    } else if (e.key.toLowerCase() === "o") {
                        // quick OFF
                        setLevel(0);
                        e.preventDefault();
                    }
                    // Try to init background sine as well
                    try {
                        initSineIfNeeded();
                    } catch (e) {}
                    disableHint();
                });

                // Toggle OFF/4 dB on counter click to avoid confusion when clicking OFF
                /*
            labelEl.addEventListener('click', () => {
                const current = Number(wrapper.dataset.level || '0');
                if (current === 0) setLevel(1); // OFF -> 4 dB
                else setLevel(0);               // any -> OFF
                try { initSineIfNeeded(); } catch (e) {}
                disableHint();
            });
            */

                // Initialize OFF and ensure label reads OFF
                // setLevel(0); // not used anymore

                // Show a short animated hint: move along the arc continuously (fwd -> back -> fwd -> back)
                let hintRunning = false;
                let hintRafId = 0;
                function animateHint() {
                    if (!hintHand) return;
                    if (hintRunning) return; // prevent duplicate runs
                    hintRunning = true;
                    const R1 = 78; // slightly bigger radius
                    const startDeg = MIN_ANGLE + STEP_DEG * 2;
                    const endDeg = startDeg + STEP_DEG * 3;
                    const baseDur = 1400; // original
                    const totalDur = baseDur * 4; // forward -> back -> forward -> back

                    // Place at exact start BEFORE showing to avoid popping at end
                    (function positionAt(deg) {
                        const rad0 = ((deg - 90) * Math.PI) / 180;
                        const x0 = Math.cos(rad0) * R1;
                        const y0 = Math.sin(rad0) * R1;
                        hintHand.style.transform = `translate(-50%, -50%) translate(${x0}px, ${y0}px)`;
                    })(startDeg);

                    hintHand.classList.add("visible");
                    const startTime = performance.now();

                    function easeOutCubic(t) {
                        return 1 - Math.pow(1 - t, 3);
                    }

                    function frame(now) {
                        // Clamp slightly below 1 to keep final segment math in-range
                        const p = Math.min(0.999, (now - startTime) / totalDur);
                        const segFloat = p * 4; // 4 segments
                        const seg = Math.floor(segFloat);
                        const localT = segFloat - seg; // 0..1 within segment
                        const eased = easeOutCubic(localT); // slow down at the end

                        let deg;
                        if (seg === 0) {
                            // forward
                            deg = startDeg + (endDeg - startDeg) * eased;
                        } else if (seg === 1) {
                            // back
                            deg = endDeg + (startDeg - endDeg) * eased;
                        } else if (seg === 2) {
                            // forward again
                            deg = startDeg + (endDeg - startDeg) * eased;
                        } else {
                            // back to start at end
                            deg = endDeg + (startDeg - endDeg) * eased;
                        }

                        const rad = ((deg - 90) * Math.PI) / 180;
                        const x = Math.cos(rad) * R1;
                        const y = Math.sin(rad) * R1;
                        hintHand.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;

                        if (p < 0.999 && hintRunning) {
                            hintRafId = requestAnimationFrame(frame);
                        } else {
                            hintRunning = false;
                            // Snap to the true final position (startDeg) and fade without moving
                            (function positionAt(deg) {
                                const rad0 = ((deg - 90) * Math.PI) / 180;
                                const x0 = Math.cos(rad0) * R1;
                                const y0 = Math.sin(rad0) * R1;
                                hintHand.style.transform = `translate(-50%, -50%) translate(${x0}px, ${y0}px)`;
                            })(startDeg);
                            setTimeout(() => {
                                hintHand.classList.remove("visible");
                                // After fade out, wait 3s then start again if not interacted
                                setTimeout(() => {
                                    if (hintLoopActive) animateHint();
                                }, hintDelayMs);
                            }, 500);
                        }
                    }

                    hintRafId = requestAnimationFrame(frame);
                }

                // Trigger the hint only when the controller is in view (4 passes total)
                function scheduleHintWhenVisible() {
                    const trigger = () => {
                        // Small delay to allow layout settle
                        setTimeout(() => {
                            if (!hintRunning) animateHint();
                        }, 150);
                    };
                    if ("IntersectionObserver" in window) {
                        const io = new IntersectionObserver(
                            (entries) => {
                                for (const entry of entries) {
                                    if (
                                        entry.isIntersecting &&
                                        entry.intersectionRatio >= 0.6
                                    ) {
                                        io.disconnect();
                                        trigger();
                                        break;
                                    }
                                }
                            },
                            { threshold: [0.6] },
                        );
                        io.observe(wrapper);
                    } else {
                        const onScrollCheck = () => {
                            const rect = wrapper.getBoundingClientRect();
                            const vh =
                                window.innerHeight ||
                                document.documentElement.clientHeight;
                            const visible =
                                rect.top < vh * 0.8 && rect.bottom > vh * 0.2;
                            if (visible) {
                                window.removeEventListener(
                                    "scroll",
                                    onScrollCheck,
                                );
                                trigger();
                            }
                        };
                        window.addEventListener("scroll", onScrollCheck, {
                            passive: true,
                        });
                        // initial check in case it's already in view
                        onScrollCheck();
                    }
                }
                // scheduleHintWhenVisible(); // not used
            });
        </script>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1 class="title">
                    Learning to See Inside Opaque Liquid Containers using
                    Speckle Vibrometry
                </h1>
                <div class="authors">
                    <a href="https://matankic.github.io">Matan Kichler</a>,
                    <a href="https://www.weizmann.ac.il/math/bagon/home"
                        >Shai Bagon</a
                    >,
                    <a href="https://www.marksheinin.com/about">Mark Sheinin</a>
                </div>
                <div class="affiliation">Weizmann Institute of Science</div>
                <br />
                <div class="conference">ICCV 2025</div>

                <div class="publication-links">
                    <span class="link-block">
                        <a
                            href="https://arxiv.org/pdf/2507.20757"
                            class="external-link"
                            target="_blank"
                        >
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    data-prefix="fas"
                                    data-icon="file-pdf"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 384 512"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"
                                    ></path>
                                </svg>
                            </span>
                            <span>Paper</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a
                            href="https://raw.githubusercontent.com/matankic/matankic.github.io/main/see_inside_containers/files/2025244494.pdf"
                            class="external-link"
                            target="_blank"
                        >
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    data-prefix="fas"
                                    data-icon="file-pdf"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 384 512"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"
                                    ></path>
                                </svg>
                            </span>
                            <span>Supp</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a
                            href="#TalkVideo"
                            class="external-link"
                            style="background-color: #e3e3e3"
                        >
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    data-prefix="fab"
                                    data-icon="youtube"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 576 512"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"
                                    ></path>
                                </svg>
                            </span>
                            <span>Video</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a
                            href="https://github.com/matankic/Learning-to-See-Inside-Opaque-Liquid-Containers-using-Speckle-Vibrometry"
                            class="external-link"
                            style="background-color: #e3e3e3"
                        >
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    data-prefix="fab"
                                    data-icon="github"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 496 512"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"
                                    ></path>
                                </svg>
                            </span>
                            <span>Code</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a
                            href="#"
                            class="external-link"
                            target="_blank"
                            style="background-color: #e3e3e3"
                        >
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 76.594292 98.560303"
                                >
                                    <g
                                        transform="translate(384.93568,-116.20738)"
                                    >
                                        <path
                                            fill="currentColor"
                                            d="m -309.7763,155.26146 a 38.296535,13.343443 0 0 1 -36.86235,9.79156 38.296535,13.343443 0 0 1 -36.86235,-9.79073 38.296535,13.343443 0 0 0 -1.43247,3.54089 h -0.002 v 0.0104 12.13034 0.001 a 38.296535,13.343443 0 0 0 5.2e-4,0 38.296535,13.343443 0 0 0 38.29637,13.34167 38.296535,13.343443 0 0 0 38.29585,-13.34167 h 0.001 v -12.14291 h -0.001 a 38.296535,13.343443 0 0 0 -1.4335,-3.54172 z"
                                        />
                                        <path
                                            fill="currentColor"
                                            d="m -346.63879,116.20738 a 38.296535,10.254843 0 0 0 -38.29482,10.2464 h -0.002 v 0.006 a 38.296535,10.254843 0 0 0 -5.2e-4,0.002 38.296535,10.254843 0 0 0 5.2e-4,0.002 v 1.85828 h -5.2e-4 v 0.0103 12.13052 10e-4 a 38.296535,13.343443 0 0 0 5.2e-4,0 38.296535,13.343443 0 0 0 38.29637,13.34131 38.296535,13.343443 0 0 0 38.29585,-13.34131 h 10e-4 v -4.67775 h 5.1e-4 v -9.33276 h -0.002 a 38.296535,10.254843 0 0 0 -38.29585,-10.2464 z"
                                        />
                                        <path
                                            fill="currentColor"
                                            d="m -309.7763,185.74128 a 38.296535,13.343443 0 0 1 -36.86235,9.79156 38.296535,13.343443 0 0 1 -36.86235,-9.79071 38.296535,13.343443 0 0 0 -1.43247,3.54086 h -0.002 v 0.0117 12.13033 0.001 a 38.296535,13.343443 0 0 0 5.2e-4,0 38.296535,13.343443 0 0 0 38.29637,13.34166 38.296535,13.343443 0 0 0 38.29585,-13.34166 h 0.001 v -12.14293 h -0.001 a 38.296535,13.343443 0 0 0 -1.4335,-3.54171 z"
                                        />
                                    </g>
                                </svg>
                            </span>
                            <span>Data</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a
                            href="#"
                            class="external-link-model"
                            target="_blank"
                            style="background-color: #e3e3e3"
                        >
                            <span class="icon model-icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 152.95038 126.03777"
                                >
                                    <g
                                        transform="translate(-519.46653,-78.899929)"
                                    >
                                        <circle
                                            style="fill: currentColor"
                                            cx="532.88135"
                                            cy="171.20122"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="532.88135"
                                            cy="111.99635"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="659.00208"
                                            cy="171.20122"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="659.00208"
                                            cy="111.99635"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="595.5799"
                                            cy="191.52287"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="595.5799"
                                            cy="141.91881"
                                            r="13.414822"
                                        />
                                        <circle
                                            style="fill: currentColor"
                                            cx="595.5799"
                                            cy="92.314751"
                                            r="13.414822"
                                        />
                                        <path
                                            style="fill: currentColor"
                                            d="m 574.18467,72.271489 -38.06463,21.974604 c 0.348,1.70825 0.53756,3.481909 0.53756,5.30396 0,2.900167 -0.466,5.683237 -1.3185,8.262777 l 23.97636,15.50696 -7.45434,12.01737 -16.7226,-26.95951 c -0.86951,2.43767 -2.0842,4.68364 -3.58241,6.66085 l 16.4478,26.51684 -16.72461,26.96247 c 1.51869,1.92782 2.7699,4.11976 3.67936,6.50985 l 16.9038,-27.25192 8.21321,13.24102 -24.50188,15.846 c 0.70013,2.36246 1.08381,4.88157 1.08381,7.49809 0,2.11287 -0.24896,4.1623 -0.71274,6.1175 l 38.23981,22.0775 c 0.0835,-2.45449 0.50006,-4.81589 1.2015,-7.03246 l -37.71562,-21.77548 26.22689,-16.56997 17.55636,28.30457 c 1.57934,-1.56441 3.36496,-2.87643 5.30475,-3.8834 l -17.31967,-27.92259 9.60726,-6.06939 c -1.44962,-1.97502 -2.62239,-4.20768 -3.45538,-6.62384 l -10.00976,6.47357 -9.86133,-15.8993 9.10313,-14.67638 10.76729,6.96362 c 0.83291,-2.41648 2.00566,-4.6487 3.45538,-6.62385 L 568.676,120.66966 585.96692,92.794444 c -1.89998,-1.092624 -3.63726,-2.484706 -5.161,-4.121024 l -17.67404,28.49333 -25.462,-16.08658 37.71629,-21.775475 c -0.70151,-2.216786 -1.11808,-4.578422 -1.2015,-7.033206 z m 43.57331,0.07625 c -0.0902,2.452084 -0.51325,4.810447 -1.22021,7.023583 l 37.60129,21.709588 -24.84956,15.70016 -17.81511,-28.471854 c -1.4931,1.673283 -3.20318,3.108982 -5.08077,4.246129 l 17.3511,27.729375 -10.88698,6.87849 c 1.45489,1.96997 2.63194,4.19869 3.47143,6.61126 l 11.28814,-7.30044 10.02514,16.02218 -9.95226,15.90448 -11.36169,-7.34782 c -0.83958,2.41261 -2.01652,4.64198 -3.47143,6.612 l 10.96053,6.92513 -17.3511,27.72938 c 1.87396,1.14539 3.57966,2.58792 5.06739,4.26834 l 17.82983,-28.49407 24.77534,15.65352 -37.60129,21.7096 c 0.70689,2.21288 1.12993,4.57101 1.22021,7.02284 l 39.05819,-22.54979 c -0.38405,-1.78956 -0.59372,-3.65224 -0.59372,-5.56897 0,-2.40187 0.32394,-4.72183 0.918,-6.91403 l -23.94092,-15.48326 8.31216,-13.28322 16.43911,26.27107 c 0.91382,-2.37825 2.16677,-4.55889 3.68471,-6.47653 l -16.25457,-25.97793 16.63702,-26.58716 c -1.54724,-1.85475 -2.83297,-3.97817 -3.79904,-6.29739 l -16.7079,26.70042 -8.38503,-13.40092 24.23844,-15.67573 c -0.73645,-2.41667 -1.14198,-4.99988 -1.14198,-7.686113 0,-1.625152 0.14867,-3.213035 0.42724,-4.749505 z"
                                            transform="matrix(0.77289354,0,0,0.69808532,134.95676,42.501834)"
                                        />
                                    </g>
                                </svg>
                            </span>
                            <span>Model</span>
                        </a>
                    </span>

                    <span class="link-block">
                        <a href="#BibTeX" class="external-link">
                            <span class="icon">
                                <svg
                                    aria-hidden="true"
                                    focusable="false"
                                    data-prefix="fa"
                                    data-icon="quote-right"
                                    role="img"
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 512 512"
                                >
                                    <path
                                        fill="currentColor"
                                        d="M464 32H336c-26.5 0-48 21.5-48 48v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48zm-288 0H48C21.5 32 0 53.5 0 80v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48z"
                                    ></path>
                                </svg>
                            </span>
                            <span>BibTeX</span>
                        </a>
                    </span>
                </div>
            </div>

            <div class="teaser-image">
                <img
                    src="images/figure_opening.png"
                    alt="System overview showing speckle vibrometry setup for liquid level detection"
                />
            </div>

            <h1 class="subtitle">
                Can you hear the contents of a Coke bottle?
            </h1>
            <p>
                <b>TL;DR:</b> Yes, we can! (and by "we," we mean a novel AI
                model). We accomplish this by sensing the tiny vibrations on the
                bottle's surface and relating them to the bottle's liquid level
                and type (i.e., Coke bottle, milk carton, etc.).
            </p>

            <div class="section">
                <h1 class="subtitle">I'm intriguedâ€”tell me (a little) more?</h1>
                <p>
                    First, we must capture these tiny surface vibrations at high
                    speeds. To achieve this, we develop a novel computational
                    imaging system that can capture object vibrations remotely
                    for a 2D grid of scene points.
                </p>

                <p>
                    We use our system to sense the vibrations of multiple scene
                    containers at once, while we "excite" the vibrations using a
                    nearby speaker by playing some
                    <span
                        onclick="toggleAudio('neveerGonnaGiveYouUp', this)"
                        style="
                            color: #209cee;
                            font-weight: bold;
                            cursor: pointer;
                        "
                        >sound</span
                    >.
                </p>
                <div style="height: 20px"></div>

                <div class="system-image">
                    <img src="images/system.png" alt="system overview" />
                    <p
                        style="
                            position: absolute;
                            left: 19%;
                            margin-top: 5px;
                            font-weight: bold;
                        "
                    >
                        capturing six containers
                    </p>
                    <p
                        style="
                            position: absolute;
                            left: 74%;
                            margin-top: 5px;
                            font-weight: bold;
                        "
                    >
                        camera system
                    </p>
                </div>

                <div style="height: 40px"></div>

                <p>
                    For each container, we measure two-axis vibrations at
                    multiple surface points (three points in the figure above).
                    We input the vibrations into a novel physics-inspired
                    Vibration Transformer, which is trained to predict the
                    container type and its hidden liquid level.
                </p>

                <div style="height: 20px"></div>

                <img
                    src="images/Architecture.png"
                    alt="Vibration-Transformer architecture diagram"
                    class="full-width-image"
                />

                <div style="height: 20px"></div>

                <h1 class="subtitle">
                    Why capture more than a single point per container?
                </h1>
                <p>
                    The vibrations of many objects can be characterized by their
                    resonant frequencies, or vibration modes. Each mode is
                    described by two things: its frequency and its shape. For
                    example, below is an illustration of the first four mode
                    shapes of a rectangular membrane:
                </p>

                <div class="membrane-wrap">
                    <img
                        class="membrane-base"
                        src="membrane/membrane_decomposition.png"
                        alt="membrane decomposition base"
                    />
                    <div class="membrane-overlay">
                        <figure class="mode">
                            <video
                                src="membrane/mode-11.mp4"
                                autoplay
                                loop
                                muted
                                playsinline
                                aria-label="mode (1,1)"
                            ></video>
                            <figcaption>mode (1,1)</figcaption>
                        </figure>
                        <figure class="mode">
                            <video
                                src="membrane/mode-12.mp4"
                                autoplay
                                loop
                                muted
                                playsinline
                                aria-label="mode (1,2)"
                            ></video>
                            <figcaption>mode (1,2)</figcaption>
                        </figure>
                        <figure class="mode">
                            <video
                                src="membrane/mode-21.mp4"
                                autoplay
                                loop
                                muted
                                playsinline
                                aria-label="mode (2,1)"
                            ></video>
                            <figcaption>mode (2,1)</figcaption>
                        </figure>
                        <figure class="mode">
                            <video
                                src="membrane/mode-22.mp4"
                                autoplay
                                loop
                                muted
                                playsinline
                                aria-label="mode (2,2)"
                            ></video>
                            <figcaption>mode (2,2)</figcaption>
                        </figure>
                    </div>
                </div>

                <p>
                    While a single vibration measurement on the object surface
                    captures frequency-related information about the surface
                    vibrations, capturing multiple points reduces ambiguity by
                    adding the shape information as well â€“ yielding more
                    reliable predictions.
                </p>

                <h1 class="subtitle">
                    So why do you need an AI model for this task?
                </h1>
                <p>
                    For a few special objects, like the wine glass below, the
                    relation between the vibration response and the fill level
                    is relatively straightforward (and not just because the
                    glass is transparent). However, the vast majority of
                    everyday containers have a rather complex vibration response
                    that stems from complex geometry, heterogeneous materials,
                    the fluid-structure interactions that alter stiffness and
                    damping, and more. Don't believe us? Try for yourself. Press
                    below the containers on the right to hear their response for
                    different fill levels. Can you spot a pattern?
                </p>

                <p>
                    If you couldn't, don't blame yourself. The vibrational
                    response depends on various factors, including object
                    geometry, materials, fluid-structure interactions, and
                    additional factors. Luckily, our Vibration Transformer has a
                    more acute "ear" than you, and can successfully classify the
                    container's hidden liquid level for a variety of containers
                    (which we demonstrate experimentally).
                </p>

                <div class="dual-panels">
                    <!-- Left panel: glass only, no source selector inside -->
                    <div class="v-slider-section" aria-hidden="false">
                        <div class="v-slider-row">
                            <div class="v-slider-col">
                                <div
                                    class="v-slider"
                                    id="vSliderL"
                                    role="slider"
                                    aria-orientation="vertical"
                                    aria-valuemin="0"
                                    aria-valuemax="5"
                                    aria-valuenow="0"
                                    tabindex="0"
                                >
                                    <div class="v-track"></div>
                                    <div class="v-water" id="vWaterL"></div>
                                    <div class="v-ticks" id="vTicksL"></div>
                                    <div
                                        class="v-thumb"
                                        id="vThumbL"
                                        aria-hidden="true"
                                    ></div>
                                    <svg
                                        class="v-hint-hand"
                                        id="vHintHandL"
                                        viewBox="0 0 64 64"
                                        aria-hidden="true"
                                    >
                                        <path
                                            fill="#ffffff"
                                            stroke="#bbb"
                                            d="M20 30v-8a4 4 0 0 1 8 0v8h2v-10a4 4 0 0 1 8 0v10h2v-8a4 4 0 0 1 8 0v16c0 7-5 12-12 12h-6c-7 0-12-5-12-12v-8z"
                                        />
                                        <circle
                                            cx="26"
                                            cy="50"
                                            r="2"
                                            fill="#bbb"
                                        />
                                    </svg>
                                </div>
                                <div class="v-slider-label">Fill Level</div>
                                <div class="v-value" id="vValueL">0%</div>
                            </div>
                            <div class="v-preview-col">
                                <img
                                    id="vPreviewL"
                                    class="v-preview-img"
                                    alt="fill level preview"
                                />
                                <button
                                    class="pushable pushable-inline"
                                    id="vPlayBtnL"
                                    type="button"
                                >
                                    <span class="front">â–¶</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Right panel: bottles with global source selector -->
                    <div class="right-column">
                        <div class="global-source-wrap">
                            <div
                                class="title"
                                style="
                                    font-size: 0.95em;
                                    font-weight: 600;
                                    color: #333;
                                "
                            >
                                Excitation Source:
                            </div>
                            <div
                                class="source-group"
                                id="sourceGroupGlobal"
                                role="group"
                                aria-label="Sound source"
                            >
                                <button
                                    class="source-btn chirp"
                                    data-src="chirp"
                                    type="button"
                                >
                                    Chirp
                                </button>
                                <button
                                    class="source-btn song active"
                                    data-src="song"
                                    type="button"
                                >
                                    Song
                                </button>
                                <button
                                    class="source-btn ambient"
                                    data-src="ambient"
                                    type="button"
                                >
                                    Ambient
                                </button>
                            </div>
                        </div>
                        <div class="v-slider-section" aria-hidden="false">
                            <div class="v-slider-row">
                                <div class="v-slider-col">
                                    <div
                                        class="v-slider"
                                        id="vSlider"
                                        role="slider"
                                        aria-orientation="vertical"
                                        aria-valuemin="0"
                                        aria-valuemax="5"
                                        aria-valuenow="0"
                                        tabindex="0"
                                    >
                                        <div class="v-track"></div>
                                        <div class="v-water" id="vWater"></div>
                                        <div class="v-ticks" id="vTicks"></div>
                                        <div
                                            class="v-thumb"
                                            id="vThumb"
                                            aria-hidden="true"
                                        ></div>
                                        <!-- hint hand icon for vertical slider -->
                                        <svg
                                            class="v-hint-hand"
                                            id="vHintHand"
                                            viewBox="0 0 64 64"
                                            aria-hidden="true"
                                        >
                                            <path
                                                fill="#ffffff"
                                                stroke="#bbb"
                                                d="M20 30v-8a4 4 0 0 1 8 0v8h2v-10a4 4 0 0 1 8 0v10h2v-8a4 4 0 0 1 8 0v16c0 7-5 12-12 12h-6c-7 0-12-5-12-12v-8z"
                                            />
                                            <circle
                                                cx="26"
                                                cy="50"
                                                r="2"
                                                fill="#bbb"
                                            />
                                        </svg>
                                    </div>
                                    <div class="v-slider-label">Fill Level</div>
                                    <div class="v-value" id="vValue">0%</div>
                                </div>
                                <div class="v-preview-col">
                                    <img
                                        id="vPreview"
                                        class="v-preview-img"
                                        alt="fill level preview"
                                    />
                                    <button
                                        class="pushable pushable-inline"
                                        id="vPlayBtn"
                                        type="button"
                                    >
                                        <span class="front">â–¶</span>
                                    </button>
                                </div>
                                <div class="v-preview-col">
                                    <img
                                        id="vPreviewCoke"
                                        class="v-preview-img"
                                        alt="coke fill level preview"
                                    />
                                    <button
                                        class="pushable pushable-inline"
                                        id="vPlayBtnCoke"
                                        type="button"
                                    >
                                        <span class="front">â–¶</span>
                                    </button>
                                </div>
                                <div class="v-preview-col">
                                    <img
                                        id="vPreviewChampagne"
                                        class="v-preview-img"
                                        alt="champagne fill level preview"
                                    />
                                    <button
                                        class="pushable pushable-inline"
                                        id="vPlayBtnChampagne"
                                        type="button"
                                    >
                                        <span class="front">â–¶</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div
                    class="below-figure-cta"
                    role="region"
                    aria-label="More examples"
                >
                    <a
                        href="dataset/ContainerDataset.html"
                        class="cta-link"
                        aria-label="Browse all containers and their sounds"
                    >
                        Browse all containers and sounds â†’
                    </a>
                </div>

                <p>
                    Moreover, our architecture is robust to the vibration
                    source, yielding correct liquid level estimates for
                    controlled and ambient scene sound sources. And, our model
                    generalizes to unseen container instances within known
                    classes (e.g., training on five Coke cans of a six-pack,
                    testing on a sixth) and fluid levels.
                </p>

                <h1 class="subtitle">Experimental results</h1>

                <p>
                    We trained our model on a dataset of 23 different container
                    types and tested it in several application-specific
                    validation categories:
                </p>

                <p>
                    <strong>(a) Within-distribution:</strong> Inference on
                    containers from the 23-container dataset, but for novel
                    speaker positions.
                </p>

                <p>
                    <strong>(b) Unseen instances:</strong> Inference on novel
                    containers, whose type exists in the 23-container dataset.
                </p>

                <p>
                    <strong>(c) Unseen liquid levels:</strong> Inference of
                    liquid levels not seen in the training set. For example,
                    training on levels {0, 20, &hellip;, 100%} and testing on
                    in-between levels {25, 50, 75%}.
                </p>

                <p>
                    <strong>(d) Ambient sound:</strong> Inference on sound
                    excitation emulating ambient background sounds.
                </p>

                <div class="results-wrap">
                    <img
                        class="results-base"
                        src="results/results_legend.png"
                        alt="results legend"
                    />
                    <div class="results-overlay" aria-hidden="true">
                        <!-- top labels at 50% and 67% -->
                        <span
                            class="label label-top"
                            style="left: 35%"
                            id="resTop50"
                            >train</span
                        >
                        <span
                            class="label label-top"
                            style="left: 72%"
                            id="resTop67"
                            >test</span
                        >

                        <!-- left-side labels at 20/40/60/80% -->
                        <span class="err-card" style="top: 16%">Error: 1%</span>
                        <span class="err-card" style="top: 41%">Error: 9%</span>
                        <span class="err-card" style="top: 66%"
                            >Error: 12%</span
                        >
                        <span class="err-card" style="top: 91%">Error: 4%</span>

                        <span
                            class="label label-left"
                            style="top: 10%"
                            id="resLeft20"
                            >(a) within-distribution</span
                        >

                        <span
                            class="label label-left"
                            style="top: 35%"
                            id="resLeft40"
                            >(b) unseen instances</span
                        >
                        <span
                            class="label label-left"
                            style="top: 60%"
                            id="resLeft60"
                            >(c) unseen liquid levels</span
                        >
                        <span
                            class="label label-left"
                            style="top: 85%"
                            id="resLeft80"
                            >(d) ambient sound</span
                        >
                    </div>
                </div>

                <p class="sv-caption">
                    Error values indicate the MAE of the fill level prediction,
                    as shown in the table below.
                </p>

                <div class="sv-wrap">
                    <div class="sv-card">
                        <table
                            class="sv-table"
                            role="table"
                            aria-label="Model Performance Evaluation"
                        >
                            <thead>
                                <tr>
                                    <th rowspan="2" class="sv-left">
                                        Test Name
                                    </th>
                                    <th colspan="2">Fill Level Prediction</th>
                                    <th>Container Classification</th>
                                </tr>
                                <tr>
                                    <th>Accuracy â†‘</th>
                                    <th>MAE â†“</th>
                                    <th>Accuracy â†‘</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">(a) within distribution</th>
                                    <td style="text-align: center">0.98</td>
                                    <td style="text-align: center">
                                        0.01 Â±0.03
                                    </td>
                                    <td style="text-align: center">1.00</td>
                                </tr>
                                <tr>
                                    <th scope="row">(b) unseen instances</th>
                                    <td style="text-align: center">0.79</td>
                                    <td style="text-align: center">
                                        0.09 Â±0.19
                                    </td>
                                    <td style="text-align: center">0.95</td>
                                </tr>
                                <tr>
                                    <th scope="row">(c) unseen liq. levels</th>
                                    <td
                                        style="
                                            text-align: center;
                                            color: #9ca3af;
                                        "
                                    >
                                        N/A
                                    </td>
                                    <td style="text-align: center">
                                        0.12 Â±0.11
                                    </td>
                                    <td style="text-align: center">0.81</td>
                                </tr>
                                <tr>
                                    <th scope="row">(d) ambient sound</th>
                                    <td style="text-align: center">0.92</td>
                                    <td style="text-align: center">
                                        0.04 Â±0.12
                                    </td>
                                    <td style="text-align: center">0.97</td>
                                </tr>
                                <tr>
                                    <th scope="row">
                                        (e) unseen liq. levels<br />
                                        + ambient sound
                                    </th>
                                    <td
                                        style="
                                            text-align: center;
                                            color: #9ca3af;
                                        "
                                    >
                                        N/A
                                    </td>
                                    <td style="text-align: center">
                                        0.15 Â±0.15
                                    </td>
                                    <td style="text-align: center">0.67</td>
                                </tr>
                                <tr>
                                    <th scope="row">
                                        (f) unseen instances<br />
                                        + ambient sound
                                    </th>
                                    <td style="text-align: center">0.59</td>
                                    <td style="text-align: center">
                                        0.16 Â±0.23
                                    </td>
                                    <td style="text-align: center">0.77</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <p class="sv-caption">
                        Arrows indicate desired metric direction: â†‘ Higher is
                        better, â†“ Lower is better.
                    </p>
                </div>

                <h1 class="subtitle">Future work</h1>

                <p>
                    We seek to study what other hidden properties of objects can
                    be revealed from their surface vibrations using our system.
                    For example, have you ever received a birthday present and
                    tried to guess what's inside by shaking the box?
                </p>

                <div style="display: flex; justify-content: center">
                    <div
                        style="
                            width: 70%;
                            padding: 0px 20px;
                            background: #fcfcfc;
                            border: 1px solid #e8e8e8;
                            border-radius: 10px;
                            display: flex;
                            flex-direction: column;
                        "
                    >
                        <img
                            src="future_work/shaking_present.png"
                            alt="shaking present"
                        />
                    </div>
                </div>

                <p>
                    We ask whether our method can be extended to inferring the
                    existence of arbitrary objects within other containers, like
                    boxes or even rooms? Potential applications of our approach
                    could include identifying packaging errors, identifying the
                    contents of shipping containers, and detecting the 3D
                    location of people and objects in a room by only measuring
                    the wall's vibrations.
                </p>

                <!-- hidden audio elements anywhere in the body: -->
                <audio
                    id="neveerGonnaGiveYouUp"
                    class="ignore-global-volume"
                    src="audios/neveerGonnaGiveYouUp.wav"
                ></audio>

                <!--             <audio id="wine_1" src="audios/wine_1.wav"></audio>
            <audio id="wine_2" src="audios/wine_2.wav"></audio> -->

                <!-- Never gonna -->
                <audio id="audio0" src="audios/never_level0.wav"></audio>
                <audio id="audio1" src="audios/never_level20.wav"></audio>
                <audio id="audio2" src="audios/never_level40.wav"></audio>
                <audio id="audio3" src="audios/never_level60.wav"></audio>
                <audio id="audio4" src="audios/never_level80.wav"></audio>
                <audio id="audio5" src="audios/never_level100.wav"></audio>

                <!-- Chirps -->
                <!--             <audio id="audio0" src="audios/level0.mp3"></audio>
            <audio id="audio1" src="audios/level20.mp3"></audio>
            <audio id="audio2" src="audios/level40.mp3"></audio>
            <audio id="audio3" src="audios/level60.mp3"></audio>
            <audio id="audio4" src="audios/level80.mp3"></audio>
            <audio id="audio5" src="audios/level100.mp3"></audio> -->
            </div>

            <div class="section" id="BibTeX">
                <h2>BibTeX</h2>
                <div class="abstract-box bibtex-container">
                    <button class="copy-button" onclick="copyBibTeX(this)">
                        Copy
                    </button>
                    <pre
                        id="bibtex-text"
                        style="
                            font-family: &quot;Courier New&quot;, monospace;
                            font-size: 0.9em;
                            line-height: 1.4;
                            margin: 15px 0px auto;
                            white-space: pre-wrap;
                        "
                    >
@inproceedings{Kichler:2025,
    title={Learning to See Inside Opaque Liquid Containers using Speckle Vibrometry},
    author={Kichler, Matan and Bagon, Shai and Sheinin, Mark},
    booktitle={Proceedings of the IEEE/CVF International Conference on Computer Vision (ICCV)},
    year={2025}
}</pre
                    >
                </div>
            </div>

            <!--     <div class="section">
        <h2>Acknowledgements</h2>
        <p>This work was supported by the Weizmann Center for New Scientists, the Institute of AI, and the MBZUAI-WIS Joint Program (SB).</p>
    </div> -->
        </div>

        <script>
            // (signal panel removed)

            // ---------------- Vertical discrete slider (6 levels) ----------------
            (function initVerticalSlider() {
                // Left panel elements
                const sliderL = document.getElementById("vSliderL");
                const thumbL = document.getElementById("vThumbL");
                const waterL = document.getElementById("vWaterL");
                const ticksWrapL = document.getElementById("vTicksL");
                const valueElL = document.getElementById("vValueL");
                const hintHandL = document.getElementById("vHintHandL");
                const previewImgL = document.getElementById("vPreviewL");
                const playBtnL = document.getElementById("vPlayBtnL");

                // Right panel elements
                const slider = document.getElementById("vSlider");
                const thumb = document.getElementById("vThumb");
                const water = document.getElementById("vWater");
                const ticksWrap = document.getElementById("vTicks");
                const valueEl = document.getElementById("vValue");
                const hintHand = document.getElementById("vHintHand");
                const previewImg = document.getElementById("vPreview");
                const previewChampagne =
                    document.getElementById("vPreviewChampagne");
                const previewCoke = document.getElementById("vPreviewCoke");
                const playBtn = document.getElementById("vPlayBtn");
                const playBtnCoke = document.getElementById("vPlayBtnCoke");
                const playBtnChampagne =
                    document.getElementById("vPlayBtnChampagne");
                if (!slider || !thumb || !ticksWrap || !valueEl || !water)
                    return;

                const NUM_LEVELS = 6; // 0..5 â†’ {0,20,40,60,80,100}%
                const VISUAL_SCALE = 0.87; // 100% logical -> 87% visual
                const toPercent = (level) => level * 20; // level index to display percent

                function buildTicks(container) {
                    if (!container) return;
                    container.innerHTML = "";
                    for (let i = 0; i < NUM_LEVELS; i++) {
                        const tick = document.createElement("div");
                        tick.className = "v-tick";
                        const pct = (i / (NUM_LEVELS - 1)) * 100; // 0..100
                        tick.style.bottom = `${pct}%`;
                        container.appendChild(tick);
                    }
                }
                buildTicks(ticksWrap);
                buildTicks(ticksWrapL);

                function imageForLevel(levelIndex) {
                    const pct = levelIndex * 20; // 0..100
                    return `images/lvl${pct}_oat.png`;
                }

                function cokeImageForLevel(levelIndex) {
                    const pct = levelIndex * 20; // 0..100
                    return `images/lvl${pct}_coke.png`;
                }

                function wineImageForLevel(levelIndex) {
                    const pct = levelIndex * 20; // 0..100
                    return `images/lvl${pct}_wine.png`;
                }

                function champagneImageForLevel(levelIndex) {
                    const pct = levelIndex * 20; // 0..100
                    return `images/lvl${pct}_champagne.png`;
                }

                function audioIdForLevel(levelIndex) {
                    // Use the mapped Never Gonna files already present in the doc
                    return `audio${levelIndex}`; // audio0..audio5 â†’ never_level{0|20|40|60|80|100}.wav
                }

                // Dynamic audio by container/source/level
                let __dynamicAudio = null;
                function audioUrlFor(containerKey, levelIndex, sourceKey) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, levelIndex),
                    );
                    const pct = toPercent(clamped);
                    return `audios/lvl${pct}_${containerKey}_${sourceKey}.wav`;
                }
                function stopDynamicAudio() {
                    try {
                        if (__dynamicAudio) {
                            __dynamicAudio.pause();
                            __dynamicAudio.currentTime = 0;
                        }
                    } catch (e) {}
                }
                function playDynamicAudio(containerKey, levelIndex) {
                    const sourceKey = window.__globalSource || "song";
                    const url = audioUrlFor(
                        containerKey,
                        levelIndex,
                        sourceKey,
                    );
                    if (!__dynamicAudio) __dynamicAudio = new Audio();
                    try {
                        __dynamicAudio.pause();
                    } catch (e) {}
                    __dynamicAudio.src = url;
                    try {
                        __dynamicAudio.muted = false;
                        __dynamicAudio.volume = 1.0;
                    } catch (e) {}
                    const p = __dynamicAudio.play();
                    if (p && typeof p.catch === "function") p.catch(() => {});
                    return __dynamicAudio;
                }

                // Static audio (no source dimension) for left wine glass
                function playWineAudio(levelIndex) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, levelIndex),
                    );
                    const pct = toPercent(clamped);
                    const url = `audios/lvl${pct}_wine.wav`;
                    if (!__dynamicAudio) __dynamicAudio = new Audio();
                    try {
                        __dynamicAudio.pause();
                    } catch (e) {}
                    __dynamicAudio.src = url;
                    try {
                        __dynamicAudio.muted = false;
                        __dynamicAudio.volume = 1.0;
                    } catch (e) {}
                    const p = __dynamicAudio.play();
                    if (p && typeof p.catch === "function") p.catch(() => {});
                    return __dynamicAudio;
                }

                // Manage a single global source selection (song default)
                (function setupGlobalSource() {
                    const group = document.getElementById("sourceGroupGlobal");
                    if (!group) return;
                    window.__globalSource = "song";
                    group.addEventListener("click", (e) => {
                        const btn = e.target.closest(".source-btn");
                        if (!btn) return;
                        window.__globalSource = btn.dataset.src || "song";
                        group
                            .querySelectorAll(".source-btn")
                            .forEach((b) => b.classList.remove("active"));
                        btn.classList.add("active");
                        releaseButtons();
                        stopAllLevelAudios();
                    });
                })();

                function stopAllLevelAudios() {
                    try {
                        // Stop legacy mapped audios
                        for (let i = 0; i < 6; i++) {
                            const a = document.getElementById(`audio${i}`);
                            if (a) {
                                a.pause();
                                a.currentTime = 0;
                            }
                        }
                    } catch (e) {}
                    // Stop dynamic audio
                    stopDynamicAudio();
                }

                function releaseButtons() {
                    try {
                        playBtn?.classList.remove("playing");
                        playBtnCoke?.classList.remove("playing");
                        playBtnChampagne?.classList.remove("playing");
                        playBtnL?.classList.remove("playing");
                    } catch (e) {}
                }

                // Ensure that when any level audio ends, both buttons are visually released
                function attachEndedHandlersOnce() {
                    try {
                        for (let i = 0; i < 6; i++) {
                            const a = document.getElementById(`audio${i}`);
                            if (!a || a.__endedHooked) continue;
                            a.addEventListener("ended", () => {
                                releaseButtons();
                            });
                            a.__endedHooked = true; // mark to avoid duplicate listeners
                        }
                    } catch (e) {}
                }
                attachEndedHandlersOnce();

                function setLevelCommon(
                    sliderEl,
                    thumbEl,
                    waterEl,
                    valueElEl,
                    previewEl,
                    level,
                ) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    const pct = (clamped / (NUM_LEVELS - 1)) * 100;
                    thumbEl.style.bottom = `${pct * VISUAL_SCALE}%`;
                    valueElEl.textContent = `${toPercent(clamped)}%`;
                    sliderEl.setAttribute("aria-valuenow", String(clamped));
                    // Update water height to match track percentage
                    const rect = sliderEl.getBoundingClientRect();
                    const trackTop = 10; // per CSS
                    const trackBottom = 10; // per CSS
                    const trackHeight = rect.height - (trackTop + trackBottom);
                    const waterHeightPx = (pct / 100) * trackHeight;
                    waterEl.style.height = `${waterHeightPx}px`;

                    // Update preview image to match discrete level
                    if (previewEl) previewEl.src = imageForLevel(clamped);
                }

                function setLevel(level) {
                    setLevelCommon(
                        slider,
                        thumb,
                        water,
                        valueEl,
                        previewImg,
                        level,
                    );
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    if (previewChampagne)
                        previewChampagne.src = champagneImageForLevel(clamped);
                    if (previewCoke)
                        previewCoke.src = cokeImageForLevel(clamped);
                }
                function setLevelL(level) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    setLevelCommon(
                        sliderL,
                        thumbL,
                        waterL,
                        valueElL,
                        previewImgL,
                        clamped,
                    );
                    if (previewImgL)
                        previewImgL.src = wineImageForLevel(clamped);
                }

                function clientYToLevel(sliderEl, clientY) {
                    const rect = sliderEl.getBoundingClientRect();
                    const trackTop = rect.top + 10; // from CSS .v-track top
                    const trackBottom = rect.bottom - 10; // from CSS .v-track bottom
                    const trackHeight = trackBottom - trackTop;
                    const y = Math.max(
                        trackTop,
                        Math.min(trackBottom, clientY),
                    );
                    const t = 1 - (y - trackTop) / trackHeight; // 0..1 bottom->top
                    const raw = t * (NUM_LEVELS - 1);
                    return raw; // return float for continuous feel
                }

                let dragging = false,
                    draggingL = false;
                let currentFloat = 0,
                    currentFloatL = 0;
                let lastDragNearestLevel = null,
                    lastDragNearestLevelL = null;

                // --- Hint loop: show hand moving 0% -> 60% -> 0%, twice, then fade and wait 3s ---
                let vHintLoopActive = true;
                let vHintRunning = false;
                let vHintRafId = 0;

                function positionHintAtPercent(hand, sliderEl, percent) {
                    if (!hand) return;
                    const rect = sliderEl.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const bottomPx =
                        10 +
                        (Math.max(0, Math.min(100, percent)) / 100) *
                            trackHeight;
                    hand.style.bottom = `${bottomPx}px`;
                }

                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                function animateBothHints(hands, sliders) {
                    const activeHands = hands.filter(Boolean);
                    const activeSliders = sliders.filter(Boolean);
                    if (activeHands.length === 0 || activeSliders.length === 0)
                        return;
                    if (!vHintLoopActive || vHintRunning) return;
                    vHintRunning = true;

                    // Place both at 0% and show
                    for (
                        let i = 0;
                        i < Math.min(activeHands.length, activeSliders.length);
                        i++
                    ) {
                        positionHintAtPercent(
                            activeHands[i],
                            activeSliders[i],
                            0,
                        );
                        activeHands[i].classList.add("visible");
                    }

                    const baseDur = 1350; // ms per segment (50% slower)
                    const segments = 4; // up, down, up, down
                    const totalDur = baseDur * segments;
                    const startTime = performance.now();

                    function frame(now) {
                        if (!vHintLoopActive) {
                            vHintRunning = false;
                            activeHands.forEach((h) =>
                                h.classList.remove("visible"),
                            );
                            return;
                        }
                        const p = Math.min(0.999, (now - startTime) / totalDur);
                        const segFloat = p * segments;
                        const seg = Math.floor(segFloat);
                        const localT = segFloat - seg; // 0..1
                        const eased = easeOutCubic(localT);

                        let percent;
                        if (seg % 2 === 0) {
                            percent = 60 * eased; // forward 0 -> 60
                        } else {
                            percent = 60 * (1 - eased); // back 60 -> 0
                        }
                        for (
                            let i = 0;
                            i <
                            Math.min(activeHands.length, activeSliders.length);
                            i++
                        ) {
                            positionHintAtPercent(
                                activeHands[i],
                                activeSliders[i],
                                percent,
                            );
                        }

                        if (p < 0.999 && vHintRunning) {
                            vHintRafId = requestAnimationFrame(frame);
                        } else {
                            // Finish cycle, fade both, then restart after delay
                            for (
                                let i = 0;
                                i <
                                Math.min(
                                    activeHands.length,
                                    activeSliders.length,
                                );
                                i++
                            ) {
                                positionHintAtPercent(
                                    activeHands[i],
                                    activeSliders[i],
                                    0,
                                );
                            }
                            vHintRunning = false;
                            setTimeout(() => {
                                activeHands.forEach((h) =>
                                    h.classList.remove("visible"),
                                );
                                setTimeout(() => {
                                    if (vHintLoopActive)
                                        animateBothHints(
                                            activeHands,
                                            activeSliders,
                                        );
                                }, 3000);
                            }, 50);
                        }
                    }
                    vHintRafId = requestAnimationFrame(frame);
                }

                function disableVHint() {
                    vHintLoopActive = false;
                    if (vHintRunning && vHintRafId)
                        cancelAnimationFrame(vHintRafId);
                    vHintRunning = false;
                    hintHand?.classList.remove("visible");
                    hintHandL?.classList.remove("visible");
                }

                function onPointerDown(e) {
                    dragging = true;
                    slider.classList.add("dragging");
                    slider.setPointerCapture?.(e.pointerId);
                    currentFloat = clientYToLevel(slider, e.clientY);
                    // live position during drag
                    const pct = (currentFloat / (NUM_LEVELS - 1)) * 100;
                    thumb.style.bottom = `${pct * VISUAL_SCALE}%`;

                    // Live water update
                    const rect = slider.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const waterHeightPx = (pct / 100) * trackHeight;
                    water.style.height = `${waterHeightPx}px`;
                    // Init lastDragNearestLevel and release play state
                    const nearest = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, Math.round(currentFloat)),
                    );
                    lastDragNearestLevel = nearest;
                    // live update label and aria while dragging
                    valueEl.textContent = `${toPercent(nearest)}%`;
                    slider.setAttribute("aria-valuenow", String(nearest));
                    releaseButtons();
                    stopAllLevelAudios();
                    // Live preview update (nearest discrete level)
                    if (previewImg) {
                        previewImg.src = imageForLevel(nearest);
                    }
                    if (previewCoke) {
                        previewCoke.src = cokeImageForLevel(nearest);
                    }
                    if (previewChampagne) {
                        previewChampagne.src = champagneImageForLevel(nearest);
                    }
                    e.preventDefault();
                    // hide only the associated hint on interaction
                    try {
                        const h = document.getElementById("vHintHand");
                        if (h) {
                            h.classList.remove("visible");
                            h.__loopActive = false;
                        }
                    } catch (e) {}
                }

                function onPointerMove(e) {
                    if (!dragging) return;
                    currentFloat = clientYToLevel(slider, e.clientY);
                    const pct = (currentFloat / (NUM_LEVELS - 1)) * 100;
                    thumb.style.bottom = `${pct * VISUAL_SCALE}%`;
                    // Live water update during drag
                    const rect = slider.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const waterHeightPx = (pct / 100) * trackHeight;
                    water.style.height = `${waterHeightPx}px`;
                    // Live preview update (nearest discrete level)
                    if (previewImg) {
                        const nearest = Math.max(
                            0,
                            Math.min(NUM_LEVELS - 1, Math.round(currentFloat)),
                        );
                        previewImg.src = imageForLevel(nearest);
                        // live update label and aria while dragging
                        valueEl.textContent = `${toPercent(nearest)}%`;
                        slider.setAttribute("aria-valuenow", String(nearest));
                        // If discrete level changed mid-drag, release both play buttons and stop audio
                        if (
                            lastDragNearestLevel === null ||
                            nearest !== lastDragNearestLevel
                        ) {
                            lastDragNearestLevel = nearest;
                            releaseButtons();
                            stopAllLevelAudios();
                        }
                    }
                    if (previewCoke) {
                        const nearest = Math.max(
                            0,
                            Math.min(NUM_LEVELS - 1, Math.round(currentFloat)),
                        );
                        previewCoke.src = cokeImageForLevel(nearest);
                    }
                    if (previewChampagne) {
                        const nearest = Math.max(
                            0,
                            Math.min(NUM_LEVELS - 1, Math.round(currentFloat)),
                        );
                        previewChampagne.src = champagneImageForLevel(nearest);
                    }
                }

                function onPointerUp(e) {
                    if (!dragging) return;
                    dragging = false;
                    slider.classList.remove("dragging");
                    slider.releasePointerCapture?.(e.pointerId);
                    // snap to nearest discrete level
                    const snapped = Math.round(currentFloat);
                    setLevel(snapped);
                }

                slider.addEventListener("pointerdown", onPointerDown);
                window.addEventListener("pointermove", onPointerMove, {
                    passive: true,
                });
                window.addEventListener("pointerup", onPointerUp);

                // Left panel interactions
                function onPointerDownL(e) {
                    draggingL = true;
                    sliderL.classList.add("dragging");
                    sliderL.setPointerCapture?.(e.pointerId);
                    currentFloatL = clientYToLevel(sliderL, e.clientY);
                    const pct = (currentFloatL / (NUM_LEVELS - 1)) * 100;
                    thumbL.style.bottom = `${pct * VISUAL_SCALE}%`;
                    const rect = sliderL.getBoundingClientRect();
                    const trackHeight = rect.height - 20;
                    waterL.style.height = `${(pct / 100) * trackHeight}px`;
                    const nearest = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, Math.round(currentFloatL)),
                    );
                    lastDragNearestLevelL = nearest;
                    releaseButtons();
                    stopAllLevelAudios();
                    if (previewImgL)
                        previewImgL.src = wineImageForLevel(nearest);
                    // live update left label and aria while dragging
                    valueElL.textContent = `${toPercent(nearest)}%`;
                    sliderL.setAttribute("aria-valuenow", String(nearest));
                    e.preventDefault();
                    // hide only the associated hint on interaction
                    try {
                        const h = document.getElementById("vHintHandL");
                        if (h) {
                            h.classList.remove("visible");
                            h.__loopActive = false;
                        }
                    } catch (e2) {}
                }
                function onPointerMoveL(e) {
                    if (!draggingL) return;
                    currentFloatL = clientYToLevel(sliderL, e.clientY);
                    const pct = (currentFloatL / (NUM_LEVELS - 1)) * 100;
                    thumbL.style.bottom = `${pct * VISUAL_SCALE}%`;
                    const rect = sliderL.getBoundingClientRect();
                    const trackHeight = rect.height - 20;
                    waterL.style.height = `${(pct / 100) * trackHeight}px`;
                    const nearest = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, Math.round(currentFloatL)),
                    );
                    if (previewImgL)
                        previewImgL.src = wineImageForLevel(nearest);
                    // live update left label and aria while dragging
                    valueElL.textContent = `${toPercent(nearest)}%`;
                    sliderL.setAttribute("aria-valuenow", String(nearest));
                    if (
                        lastDragNearestLevelL === null ||
                        nearest !== lastDragNearestLevelL
                    ) {
                        lastDragNearestLevelL = nearest;
                        releaseButtons();
                        stopAllLevelAudios();
                    }
                }
                function onPointerUpL(e) {
                    if (!draggingL) return;
                    draggingL = false;
                    sliderL.classList.remove("dragging");
                    sliderL.releasePointerCapture?.(e.pointerId);
                    const snapped = Math.round(currentFloatL);
                    setLevelL(snapped);
                }
                sliderL?.addEventListener("pointerdown", onPointerDownL);
                window.addEventListener("pointermove", onPointerMoveL, {
                    passive: true,
                });
                window.addEventListener("pointerup", onPointerUpL);

                // Keyboard: ArrowUp/Down to move between 6 levels
                slider.addEventListener("keydown", (e) => {
                    const now = Number(
                        slider.getAttribute("aria-valuenow") || "0",
                    );
                    const releaseAndStop = () => {
                        releaseButtons();
                        stopAllLevelAudios();
                    };
                    if (e.key === "ArrowUp") {
                        releaseAndStop();
                        setLevel(now + 1);
                        e.preventDefault();
                    } else if (e.key === "ArrowDown") {
                        releaseAndStop();
                        setLevel(now - 1);
                        e.preventDefault();
                    } else if (e.key === "Home") {
                        releaseAndStop();
                        setLevel(0);
                        e.preventDefault();
                    } else if (e.key === "End") {
                        releaseAndStop();
                        setLevel(NUM_LEVELS - 1);
                        e.preventDefault();
                    }
                    try {
                        const h = document.getElementById("vHintHand");
                        if (h) {
                            h.classList.remove("visible");
                            h.__loopActive = false;
                        }
                    } catch (e2) {}
                });

                // Init at 0%
                setLevel(0);
                setLevelL(0);
                // Start independent hint loops (not synchronized)
                const jitter = () => 2500 + Math.random() * 1500; // 2.5â€“4s

                function animateSingleHint(hand, sliderEl) {
                    if (!hand || !sliderEl) return;
                    if (hand.__running) return;
                    if (hand.__loopActive === false) return;
                    hand.__loopActive = true;
                    hand.__running = true;
                    positionHintAtPercent(hand, sliderEl, 0);
                    hand.classList.add("visible");
                    const baseDur = 1350; // 50% slower
                    const segments = 4; // up, down, up, down
                    const totalDur = baseDur * segments;
                    const startTime = performance.now();
                    function frame(now) {
                        if (hand.__loopActive === false) {
                            hand.__running = false;
                            hand.classList.remove("visible");
                            return;
                        }
                        const p = Math.min(0.999, (now - startTime) / totalDur);
                        const seg = Math.floor(p * segments);
                        const localT = p * segments - seg;
                        const eased = easeOutCubic(localT);
                        const percent =
                            seg % 2 === 0 ? 60 * eased : 60 * (1 - eased);
                        positionHintAtPercent(hand, sliderEl, percent);
                        if (p < 0.999 && hand.__loopActive !== false) {
                            hand.__rafId = requestAnimationFrame(frame);
                        } else {
                            positionHintAtPercent(hand, sliderEl, 0);
                            hand.__running = false;
                            setTimeout(() => {
                                hand.classList.remove("visible");
                                setTimeout(() => {
                                    if (hand.__loopActive !== false)
                                        animateSingleHint(hand, sliderEl);
                                }, jitter()); // random delay each cycle
                            }, 50);
                        }
                    }
                    hand.__rafId = requestAnimationFrame(frame);
                }
                setTimeout(() => {
                    animateSingleHint(hintHand, slider);
                }, 800);
                setTimeout(() => {
                    animateSingleHint(hintHandL, sliderL);
                }, 500);

                // Wire play button (Oat): map to dynamic audios
                if (playBtn) {
                    playBtn.addEventListener("click", () => {
                        attachEndedHandlersOnce();
                        if (playBtn.classList.contains("playing")) {
                            stopAllLevelAudios();
                            releaseButtons();
                            return;
                        }
                        releaseButtons();
                        stopAllLevelAudios();
                        const level = Number(
                            slider.getAttribute("aria-valuenow") || "0",
                        );
                        const a = playDynamicAudio("oat", level);
                        playBtn.classList.add("playing");
                        a.addEventListener("ended", function onEnd() {
                            playBtn.classList.remove("playing");
                            a.removeEventListener("ended", onEnd);
                        });
                    });
                }

                // Left panel play button â†’ play audios/lvl{x}_wine.wav (no source dimension)
                if (playBtnL) {
                    playBtnL.addEventListener("click", () => {
                        attachEndedHandlersOnce();
                        if (playBtnL.classList.contains("playing")) {
                            stopAllLevelAudios();
                            releaseButtons();
                            return;
                        }
                        releaseButtons();
                        stopAllLevelAudios();
                        const level = Number(
                            sliderL.getAttribute("aria-valuenow") || "0",
                        );
                        const a = playWineAudio(level);
                        playBtnL.classList.add("playing");
                        a.addEventListener("ended", function onEnd() {
                            playBtnL.classList.remove("playing");
                            a.removeEventListener("ended", onEnd);
                        });
                    });
                }

                // Second play button (Coke): dynamic audios
                if (playBtnCoke) {
                    playBtnCoke.addEventListener("click", () => {
                        attachEndedHandlersOnce();
                        if (playBtnCoke.classList.contains("playing")) {
                            stopAllLevelAudios();
                            releaseButtons();
                            return;
                        }
                        releaseButtons();
                        stopAllLevelAudios();
                        const level = Number(
                            slider.getAttribute("aria-valuenow") || "0",
                        );
                        const a = playDynamicAudio("coke", level);
                        playBtnCoke.classList.add("playing");
                        a.addEventListener("ended", function onEnd() {
                            playBtnCoke.classList.remove("playing");
                            a.removeEventListener("ended", onEnd);
                        });
                    });
                }

                // Third play button (Champagne): dynamic audios
                if (playBtnChampagne) {
                    playBtnChampagne.addEventListener("click", () => {
                        attachEndedHandlersOnce();
                        if (playBtnChampagne.classList.contains("playing")) {
                            stopAllLevelAudios();
                            releaseButtons();
                            return;
                        }
                        releaseButtons();
                        stopAllLevelAudios();
                        const level = Number(
                            slider.getAttribute("aria-valuenow") || "0",
                        );
                        const a = playDynamicAudio("champagne", level);
                        playBtnChampagne.classList.add("playing");
                        a.addEventListener("ended", function onEnd() {
                            playBtnChampagne.classList.remove("playing");
                            a.removeEventListener("ended", onEnd);
                        });
                    });
                }
            })();

            // (signal panel removed)
        </script>
    </body>
</html>
