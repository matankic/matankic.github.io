<!doctype html>
<html lang="en">
    <head>
        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;500;600;700&display=swap&family=Noto+Sans:wght@400;500;600&display=swap"
            rel="stylesheet"
        />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            Learning to See Inside Opaque Liquid Containers using Speckle
            Vibrometry
        </title>
        <style>
            body {
                font-family: "Helvetica", Arial, sans-serif;
                line-height: 1.5;
                color: #4a4a4a;
                font-size: 1em;
                font-weight: 400;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                margin: 0;
                padding: 0;
            }

            .construction-banner {
                background: #f8f9fa;
                color: #6c757d;
                text-align: center;
                padding: 10px 20px;
                font-weight: 500;
                font-size: 1.5em;
                border-bottom: 1px solid #dee2e6;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1000;
            }

            body {
                padding-top: 50px; /* Add space for the fixed banner */
            }

            .container {
                max-width: 960px;
                margin: 0 auto;
                padding: 40px 20px;
            }

            .header {
                text-align: center;
                margin-bottom: 40px;
            }

            .title {
                font-family:
                    helvetica,
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    sans-serif;
                font-size: 3em;
                font-weight: bold;
                color: #4a4a4a;
            }

            .subtitle {
                font-family:
                    helvetica,
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    sans-serif;
                font-size: 1.3em;
                font-weight: bold;
                color: #4a4a4a;
                margin-top: 1.2em;
                margin-bottom: -0.2em;
            }

            .authors {
                font-size: 1.5em;
            }

            .authors a {
                color: #209cee;
                text-decoration: none;
            }

            .authors a:hover {
                text-decoration: underline;
            }

            .affiliation {
                font-size: 1.5em;
            }

            .conference {
                font-size: 1.7em;
                margin-bottom: 25px;
            }

            .publication-links {
                display: flex;
                justify-content: center;
                gap: 10px;
                flex-wrap: wrap;
                margin-bottom: 30px;
            }

            .link-block {
                display: inline-block;
            }

            .external-link {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 10px 16px;
                background: #363636;
                color: white;
                text-decoration: none;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                transition: background-color 0.2s ease;
                border: none;
                cursor: pointer;
            }

            .external-link:hover {
                background: #4a4a4a;
                color: white;
            }

            .external-link .icon {
                width: 22px;
                height: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .external-link .icon svg {
                width: 25px;
                height: 18px;
                fill: currentColor;
            }

            .external-link-model {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 10px 16px;
                background: #363636;
                color: white;
                text-decoration: none;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 500;
                transition: background-color 0.2s ease;
                border: none;
                cursor: pointer;
            }

            .external-link-model:hover {
                background: #4a4a4a;
                color: white;
            }

            .external-link-model .icon {
                width: 22px;
                height: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .external-link-model .icon svg {
                width: 25px;
                height: 18px;
                fill: currentColor;
            }

            .teaser-image {
                text-align: center;
                margin: 40px 0;
            }

            .teaser-image img {
                max-width: 55%;
                height: auto;
                border-radius: 8px;
            }

            .fill-level-image {
                position: relative;
                max-width: 100%;
                width: 75%;
                margin: auto;
            }

            .fill-level-image img {
                display: block;
                width: 100%;
                height: auto;
            }

            .system-image {
                position: relative;
                max-width: 100%;
                width: 80%;
                margin: auto;
            }

            .system-image img {
                display: block;
                width: 100%;
                height: auto;
            }

            .section {
                margin-bottom: 50px;
            }

            .section h2 {
                font-size: 1.8em;
                font-weight: normal;
                margin-bottom: 20px;
                color: #333;
            }

            .publication-title {
                font-size: 1.1em;
                font-weight: 500;
                margin-bottom: 10px;
                color: #333;
            }

            .buttons {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 15px;
            }

            .btn {
                padding: 8px 16px;
                background: #333;
                color: white;
                text-decoration: none;
                border-radius: 4px;
                font-size: 0.9em;
                transition: background-color 0.2s;
            }

            .btn:hover {
                background: #555;
            }

            .abstract-box {
                background: #f5f5f5;
                border-radius: 8px;
                padding: 20px;
                margin: 20px 0;
                font-size: 1em;
                line-height: 1.7;
                text-align: justify;
            }

            .results-box {
                background: #f5f5f5;
                border-radius: 8px;
                padding: 20px;
                margin: 20px 0;
            }

            .results-box ul {
                margin: 0;
                padding-left: 20px;
            }

            .results-box li {
                margin-bottom: 8px;
                font-size: 1em;
            }

            /*         .full-width-image {
            width: 140%;
            max-width: 140%;
            margin-left: -20%;
            margin-right: -20%;
            display: block;
        } */

            .full-width-image {
                width: 100%;
                max-width: 100%;
                display: block;
            }

            .method-image {
                text-align: center;
                margin: 30px 0;
            }

            .method-image img {
                max-width: 100%;
                height: auto;
            }

            .demo-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin: 30px 0;
            }

            .demo-item {
                background: #f5f5f5;
                border-radius: 8px;
                padding: 20px;
                text-align: center;
            }

            .demo-placeholder {
                width: 100%;
                height: 150px;
                background: #e9ecef;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 15px;
                color: #666;
                font-size: 0.9em;
            }

            .demo-caption {
                font-size: 0.9em;
                color: #666;
                line-height: 1.4;
            }

            p {
                font-size: 1em;
                text-align: justify;
                margin-bottom: 15px;
                line-height: 1.6;
            }

            .bibtex-container {
                position: relative;
            }

            .copy-button {
                position: absolute;
                top: 15px;
                right: 15px;
                background: #333;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8em;
                transition: background-color 0.2s;
            }

            .copy-button:hover {
                background: #555;
            }

            .copy-button.copied {
                background: #28a745;
            }

            .pushable {
                background: hsl(0deg 0% 60%);
                border-radius: 50px;
                border: none;
                padding: 0;
                cursor: pointer;
                outline-offset: 4px;
                position: absolute;
                bottom: -55px;
                transform: translateX(-50%);
            }

            .front {
                display: block;
                padding: 6px 20px;
                border-radius: 50px;
                font-size: 1.25rem;
                background: hsl(0deg 0% 90%);
                color: hsl(0deg 0% 50%);
                transform: translateY(-6px);
            }

            .pushable:active .front {
                transform: translateY(-2px);
            }

            .pushable.playing .front {
                transform: translateY(-2px);
            }

            /* Rotary volume control */
            .controller-row {
                display: flex;
                gap: 28px;
                align-items: center;
                justify-content: center;
                flex-wrap: wrap;
            }

            .volume-control {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
                margin-left: 0; /* centered layout */
                user-select: none;
            }

            .rotary-wrapper {
                position: relative;
                width: 120px;
                height: 120px;
                cursor: default;
            }

            .rotary-knob {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 92px;
                height: 92px;
                transform: translate(-50%, -50%); /* keep lighting static */
                border-radius: 50%;
                background: radial-gradient(
                    65% 65% at 30% 30%,
                    #1a1a1a 0%,
                    #0f0f0f 60%,
                    #000 100%
                );
                box-shadow:
                    inset 0 2px 6px rgba(255, 255, 255, 0.06),
                    inset 0 -8px 16px rgba(0, 0, 0, 0.8),
                    0 6px 18px rgba(0, 0, 0, 0.3);
                border: 1px solid #0c0c0c;
            }

            .rotary-wrapper:hover {
                cursor: pointer;
            }
            .rotary-wrapper.dragging {
                cursor: grabbing;
            }
            .rotary-wrapper:active {
                cursor: grabbing;
            }

            .rotary-knob::before {
                content: "";
                position: absolute;
                inset: 10px;
                border-radius: 50%;
                background: radial-gradient(
                    60% 60% at 30% 30%,
                    #222 0%,
                    #111 60%,
                    #0a0a0a 100%
                );
            }

            .rotary-angle {
                position: absolute;
                inset: 0;
            }

            .rotary-indicator {
                position: absolute;
                top: 14px;
                left: 50%;
                width: 3px;
                height: 24px;
                transform: translateX(-50%);
                background: linear-gradient(180deg, #e8e8e8 0%, #cfcfcf 100%);
                border-radius: 2px;
                box-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
            }

            .ticks {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 120px;
                height: 120px;
                transform: translate(-50%, -50%);
                pointer-events: none;
            }

            .tick {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 3px;
                height: 12px;
                background: #d9d9d9; /* light gray for not reached */
                border-radius: 2px;
                opacity: 0.9;
                box-shadow: 0 0 0.5px rgba(255, 255, 255, 0.15);
            }

            .tick.active {
                background: #5e5e5e; /* darker gray for reached */
            }

            .volume-readout {
                display: flex;
                flex-direction: column;
                gap: 6px;
                align-items: center;
            }

            .volume-readout .title {
                font-size: 0.95em;
                font-weight: 600;
                margin: 0;
                color: #333;
                text-align: center;
            }

            .volume-label {
                display: inline-block;
                min-width: 44px;
                padding: 2px 8px;
                border-radius: 12px;
                background: #111;
                color: #f0f0f0;
                font-variant-numeric: tabular-nums;
                text-align: center;
                font-weight: 600;
                letter-spacing: 0.5px;
                cursor: pointer;
                outline: none;
            }

            .volume-label:hover {
                filter: brightness(1.08);
            }
            .volume-label:focus {
                box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.35);
            }

            /* Interactive hint: hand-grip icon following an arc, hidden on interaction */
            .hint-hand {
                position: absolute;
                top: 50%;
                left: 50%;
                width: 34px;
                height: 34px;
                opacity: 0; /* start hidden; fade in for demo */
                transition: opacity 300ms ease;
                pointer-events: none;
                transform: translate(-50%, -50%);
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
            }

            .hint-hand.visible {
                opacity: 0.95;
            }

            /* Signal panel */
            .signal-panel {
                flex: 1 1 480px; /* restore previous preferred size */
                min-width: 380px;
                max-width: 620px;
            }

            .snr-figure-container {
                text-align: center;
                margin: 0;
                width: 100%;
                position: relative;
            }

            .snr-figure {
                max-width: 100%;
                height: 250px;
                border-radius: 8px;
            }

            .signal-title {
                font-size: 0.95em;
                font-weight: 600;
                margin: 0 0 6px;
                color: #333;
            }

            .signal-card {
                background: #ffffff;
                border: 1px solid #e5e5e5;
                border-radius: 10px;
                padding: 12px 12px 8px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.06);
            }

            .signal-canvas-wrap {
                position: relative;
                width: 100%;
                height: 160px;
                border-radius: 8px;
                overflow: hidden;
                background: linear-gradient(180deg, #fafafa 0%, #f7f7f7 100%);
                border: 1px solid #ececec;
            }

            /* Simple file:// friendly SVG scroller */
            .signal-viewport {
                position: relative;
                width: 100%;
                height: 160px;
                overflow: hidden;
                border-radius: 8px;
            }
            .signal-strip {
                position: absolute;
                inset: 0;
                width: 200%;
                height: 100%;
                display: flex;
                animation: signalScroll var(--scroll-duration, 8s) linear
                    infinite;
            }
            .signal-frame {
                width: 50%;
                height: 100%;
            }
            .signal-img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }
            @keyframes signalScroll {
                from {
                    transform: translateX(0);
                }
                to {
                    transform: translateX(-50%);
                }
            }

            .signal-meta {
                margin-top: 8px;
                font-size: 0.9em;
                color: #555;
            }

            .signal-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 12px;
                margin-top: 8px;
            }

            @media (max-width: 768px) {
                .container {
                    padding: 20px 15px;
                }

                .title {
                    font-size: 1.8em;
                }

                .authors a {
                    margin-right: 10px;
                }

                .demo-grid {
                    grid-template-columns: 1fr;
                }

                .publication-links {
                    gap: 8px;
                }

                .external-link {
                    padding: 8px 12px;
                    font-size: 0.85em;
                }

                .external-link-model {
                    padding: 8px 12px;
                    font-size: 0.85em;
                }

                .full-width-image {
                    width: 120%;
                    margin-left: -10%;
                    margin-right: -10%;
                }
            }

            .gif-overlay {
                position: absolute;
                top: 47px;
                left: calc(50% + 104px);
                transform: translateX(-50%);
                z-index: 10;
            }

            .gif-profile {
                width: 123px;
                height: 123px;
                border-radius: 50%;
                border: 3px solid white;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                object-fit: cover;
            }

            .gif-profile.active {
                border-color: #209cee;
                box-shadow: 0 0 15px rgba(32, 156, 238, 0.5);
            }

            /* Vertical slider (blue accent, discrete 6 levels) */
            .v-slider-section {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 10px;
                margin: 16px 0 26px;
            }

            .v-slider-label {
                font-size: 0.95em;
                font-weight: 600;
                color: #333;
                margin-top: 8px; /* extra space from slider */
            }

            .v-slider {
                position: relative;
                width: 44px;
                height: 260px;
                user-select: none;
                touch-action: none;
                outline: none;
            }

            .v-track {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 10px;
                bottom: 10px;
                width: 8px;
                border-radius: 6px;
                background: linear-gradient(180deg, #e9f0ff 0%, #d8e5ff 100%);
                box-shadow: inset 0 0 0 1px rgba(13, 110, 253, 0.12);
                z-index: 0;
            }

            .v-water {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                bottom: 10px; /* align with track bottom */
                width: 8px;
                height: 0px; /* will be updated in JS */
                border-radius: 6px;
                background: linear-gradient(180deg, #6fb6ff 0%, #0d6efd 70%);
                box-shadow:
                    inset 0 -2px 6px rgba(0, 0, 0, 0.12),
                    0 0 0 1px rgba(13, 110, 253, 0.18);
                transition: height 140ms ease;
                z-index: 1;
            }

            .v-ticks {
                position: absolute;
                inset: 15px 0 10px 0;
                z-index: 2;
                pointer-events: none;
            }
            .v-tick {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                width: 5px;
                height: 5px;
                border-radius: 50%;
                background: rgba(13, 110, 253, 0.3);
            }

            .v-thumb {
                position: absolute;
                left: 50%;
                transform: translate(-50%, 50%);
                bottom: 0%;
                width: 22px;
                height: 22px;
                border-radius: 50%;
                background: #0d6efd;
                border: 3px solid #ffffff;
                box-shadow: 0 4px 10px rgba(13, 110, 253, 0.35);
                cursor: grab;
                transition: bottom 140ms ease;
                z-index: 3;
            }
            .v-slider.dragging .v-thumb {
                cursor: grabbing;
                transition: none;
            }
            .v-slider.dragging .v-water {
                transition: none;
            }

            /* Vertical slider hint hand */
            .v-hint-hand {
                position: absolute;
                left: calc(50% - 40px); /* shift slightly left of the bar */
                transform: none;
                bottom: 10px; /* start at track bottom */
                width: 30px;
                height: 30px;
                opacity: 0;
                transition: opacity 300ms ease;
                pointer-events: none;
                z-index: 4;
                filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
            }
            .v-hint-hand.visible {
                opacity: 0.95;
            }

            .v-value {
                display: inline-block;
                min-width: 48px;
                text-align: center;
                font-weight: 600;
                color: #0d6efd;
                background: #eef4ff;
                border: 1px solid rgba(13, 110, 253, 0.25);
                border-radius: 999px;
                padding: 1px 4px;
                font-variant-numeric: tabular-nums;
            }
        </style>
        <script>
            function toggleAudio(audioId, button) {
                const audio = document.getElementById(audioId);

                if (audio.paused) {
                    // Start playing
                    audio.play();
                    button.classList.add("playing");

                    // Remove the class when audio ends
                    audio.addEventListener(
                        "ended",
                        function () {
                            button.classList.remove("playing");
                        },
                        { once: true },
                    );
                } else {
                    // Stop playing
                    audio.pause();
                    audio.currentTime = 0;
                    button.classList.remove("playing");
                }
            }

            function copyBibTeX(button) {
                const bibtexText =
                    document.getElementById("bibtex-text").textContent;

                // Use the modern Clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard
                        .writeText(bibtexText)
                        .then(function () {
                            // Show success feedback
                            const originalText = button.textContent;
                            button.textContent = "Copied!";
                            button.classList.add("copied");

                            setTimeout(function () {
                                button.textContent = originalText;
                                button.classList.remove("copied");
                            }, 2000);
                        })
                        .catch(function (err) {
                            console.error("Failed to copy text: ", err);
                            fallbackCopy(bibtexText, button);
                        });
                } else {
                    // Fallback for older browsers or non-secure contexts
                    fallbackCopy(bibtexText, button);
                }
            }

            function fallbackCopy(text, button) {
                // Create a temporary textarea element
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);

                textArea.focus();
                textArea.select();

                try {
                    document.execCommand("copy");
                    // Show success feedback
                    const originalText = button.textContent;
                    button.textContent = "Copied!";
                    button.classList.add("copied");

                    setTimeout(function () {
                        button.textContent = originalText;
                        button.classList.remove("copied");
                    }, 2000);
                } catch (err) {
                    console.error("Fallback copy failed: ", err);
                    button.textContent = "Copy failed";
                    setTimeout(function () {
                        button.textContent = "Copy";
                    }, 2000);
                } finally {
                    document.body.removeChild(textArea);
                }
            }

            // Rotary knob logic
            document.addEventListener("DOMContentLoaded", function () {
                const wrapper = document.getElementById("volumeKnob");
                if (!wrapper) return;

                const knob = wrapper.querySelector(".rotary-knob");
                const angleLayer = knob.querySelector(".rotary-angle");
                const ticksContainer = wrapper.querySelector(".ticks");
                const labelEl = document.getElementById("volumeLabel");
                const hintHand = document.getElementById("hintHand");
                let hintLoopActive = true; // keep showing hint until user changes volume
                const hintDelayMs = 3000; // wait 3s before starting next hint loop

                // -------- Background sine tone (422 Hz) --------
                let sineInitialized = false;
                let audioCtx = null;
                let sineGain = null;
                let oscillator = null;

                function initSineIfNeeded() {
                    if (sineInitialized) {
                        if (audioCtx?.state === "suspended") {
                            audioCtx.resume?.();
                        }
                        return;
                    }
                    try {
                        const Ctx =
                            window.AudioContext || window.webkitAudioContext;
                        audioCtx = new Ctx();
                        sineGain = audioCtx.createGain();
                        sineGain.gain.value = 0.0; // start muted
                        oscillator = audioCtx.createOscillator();
                        oscillator.type = "sine";
                        oscillator.frequency.value = 422; // Hz
                        oscillator
                            .connect(sineGain)
                            .connect(audioCtx.destination);
                        oscillator.start();
                        sineInitialized = true;
                    } catch (e) {
                        // no-op if Web Audio not available
                    }
                }

                function setSineVolume(volume01) {
                    if (!sineInitialized || !sineGain) return;
                    const v = Math.max(0, Math.min(1, volume01));
                    try {
                        const now = audioCtx.currentTime || 0;
                        // Smooth ramp for nicer UX
                        sineGain.gain.setTargetAtTime(v, now, 0.05);
                    } catch (e) {
                        sineGain.gain.value = v;
                    }
                }

                const MIN_ANGLE = -120; // degrees
                const MAX_ANGLE = 120; // degrees
                const NUM_LEVELS = 12; // 0..11
                const STEP_DEG = (MAX_ANGLE - MIN_ANGLE) / (NUM_LEVELS - 1);

                // Remove signal state (not used now)

                // Generate ticks on a not-full circle arc
                for (let i = 0; i < NUM_LEVELS; i++) {
                    const angle = MIN_ANGLE + i * STEP_DEG;
                    const tick = document.createElement("div");
                    tick.className = "tick";
                    tick.style.transform = `translate(-50%, -50%) rotate(${angle}deg) translate(0, -56px)`;
                    ticksContainer.appendChild(tick);
                }

                function setLevel(level) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    const angle = MIN_ANGLE + clamped * STEP_DEG;
                    // Rotate only the indicator layer; keep knob lighting static
                    angleLayer.style.transform = `rotate(${angle}deg)`;

                    // Update ticks highlight
                    const ticks = ticksContainer.querySelectorAll(".tick");
                    ticks.forEach((t, idx) => {
                        if (idx <= clamped) t.classList.add("active");
                        else t.classList.remove("active");
                    });

                    // Update label: OFF, 4 dB, 8 dB, ...
                    const db = clamped * 4;
                    labelEl.textContent = clamped === 0 ? "OFF" : `${db} dB`;

                    // Set global audio volume
                    const baseVolume = clamped / (NUM_LEVELS - 1);
                    const adjustedVolume = baseVolume * 0.033; // ~96.7% reduction
                    document.querySelectorAll("audio").forEach((a) => {
                        try {
                            a.volume = adjustedVolume;
                        } catch (e) {}
                    });
                    // Also update background sine tone volume
                    try {
                        setSineVolume(adjustedVolume);
                    } catch (e) {}

                    // Update speckle vibration GIF
                    const speckleGif = document.getElementById("speckleGif");
                    if (speckleGif && clamped > 0) {
                        speckleGif.src = `SNR_experiment/speckle_vibration_fast_level_${clamped}.gif`;
                    } else if (speckleGif) {
                        // For OFF level, show level 1 GIF
                        speckleGif.src = `SNR_experiment/speckle_vibration_fast_level_1.gif`;
                    }

                    // a11y
                    wrapper.setAttribute("aria-valuenow", String(clamped));
                    wrapper.setAttribute(
                        "aria-valuetext",
                        clamped === 0 ? "OFF" : `${db} dB`,
                    );

                    wrapper.dataset.level = String(clamped);

                    // Sync SVG panel to level
                    updateSignalFromLevel(clamped);
                }

                function angleToLevel(angleDeg) {
                    const clampedAngle = Math.max(
                        MIN_ANGLE,
                        Math.min(MAX_ANGLE, angleDeg),
                    );
                    const raw = (clampedAngle - MIN_ANGLE) / STEP_DEG;
                    // Make the first bin (OFF) slightly larger for easier access
                    // If we're within half-a-step of MIN_ANGLE, snap to 0
                    if (clampedAngle <= MIN_ANGLE + STEP_DEG * 0.6) return 0;
                    return Math.round(raw);
                }

                function clientToAngle(clientX, clientY) {
                    const rect = wrapper.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dx = clientX - cx;
                    const dy = clientY - cy;
                    // Base angle: 0 at +X; shift so 12 o'clock is 0 deg
                    let deg = (Math.atan2(dy, dx) * 180) / Math.PI + 90;
                    // Normalize to [-180, 180] so negative angles are reachable (left side)
                    if (deg > 180) deg -= 360;
                    if (deg < -180) deg += 360;
                    return deg;
                }

                let dragging = false;
                let pointerDownInside = false;

                function disableHint() {
                    hintLoopActive = false;
                    if (hintRunning && hintRafId)
                        cancelAnimationFrame(hintRafId);
                    hintRunning = false;
                    hintHand?.classList.remove("visible");
                }

                function onPointerDown(e) {
                    dragging = true;
                    pointerDownInside = true;
                    wrapper.classList.add("dragging");
                    wrapper.setPointerCapture?.(e.pointerId);
                    const angle = clientToAngle(e.clientX, e.clientY);
                    // If user starts at far-left above OFF threshold, snap to OFF
                    const tentative = angleToLevel(angle);
                    if (tentative === 1 && angle < MIN_ANGLE + STEP_DEG * 0.3) {
                        setLevel(0);
                    } else {
                        setLevel(tentative);
                    }
                    e.preventDefault();
                    // Init background sine on first interaction (user gesture)
                    try {
                        initSineIfNeeded();
                    } catch (e) {}
                    // Stop hint loop on first interaction
                    disableHint();
                }

                function onPointerMove(e) {
                    if (!dragging) return;
                    const angle = clientToAngle(e.clientX, e.clientY);
                    setLevel(angleToLevel(angle));
                }

                function onPointerUp(e) {
                    dragging = false;
                    pointerDownInside = false;
                    wrapper.classList.remove("dragging");
                    wrapper.releasePointerCapture?.(e.pointerId);
                }

                // Click/drag support
                wrapper.addEventListener("pointerdown", onPointerDown);
                window.addEventListener("pointermove", onPointerMove);
                window.addEventListener("pointerup", onPointerUp);

                // Keyboard support
                wrapper.addEventListener("keydown", (e) => {
                    const current = Number(wrapper.dataset.level || "0");
                    if (e.key === "ArrowRight" || e.key === "ArrowUp") {
                        setLevel(current + 1);
                        e.preventDefault();
                    } else if (e.key === "ArrowLeft" || e.key === "ArrowDown") {
                        setLevel(current - 1);
                        e.preventDefault();
                    } else if (e.key.toLowerCase() === "o") {
                        // quick OFF
                        setLevel(0);
                        e.preventDefault();
                    }
                    // Try to init background sine as well
                    try {
                        initSineIfNeeded();
                    } catch (e) {}
                    disableHint();
                });

                // Toggle OFF/4 dB on counter click to avoid confusion when clicking OFF
                labelEl.addEventListener("click", () => {
                    const current = Number(wrapper.dataset.level || "0");
                    if (current === 0)
                        setLevel(1); // OFF -> 4 dB
                    else setLevel(0); // any -> OFF
                    try {
                        initSineIfNeeded();
                    } catch (e) {}
                    disableHint();
                });

                // Initialize OFF and ensure label reads OFF
                setLevel(0);

                // Show a short animated hint: move along the arc continuously (fwd -> back -> fwd -> back)
                let hintRunning = false;
                let hintRafId = 0;
                function animateHint() {
                    if (!hintHand) return;
                    if (hintRunning) return; // prevent duplicate runs
                    hintRunning = true;
                    const R1 = 78; // slightly bigger radius
                    const startDeg = MIN_ANGLE + STEP_DEG * 2;
                    const endDeg = startDeg + STEP_DEG * 3;
                    const baseDur = 1400; // original
                    const totalDur = baseDur * 4; // forward -> back -> forward -> back

                    // Place at exact start BEFORE showing to avoid popping at end
                    (function positionAt(deg) {
                        const rad0 = ((deg - 90) * Math.PI) / 180;
                        const x0 = Math.cos(rad0) * R1;
                        const y0 = Math.sin(rad0) * R1;
                        hintHand.style.transform = `translate(-50%, -50%) translate(${x0}px, ${y0}px)`;
                    })(startDeg);

                    hintHand.classList.add("visible");
                    const startTime = performance.now();

                    function easeOutCubic(t) {
                        return 1 - Math.pow(1 - t, 3);
                    }

                    function frame(now) {
                        // Clamp slightly below 1 to keep final segment math in-range
                        const p = Math.min(0.999, (now - startTime) / totalDur);
                        const segFloat = p * 4; // 4 segments
                        const seg = Math.floor(segFloat);
                        const localT = segFloat - seg; // 0..1 within segment
                        const eased = easeOutCubic(localT); // slow down at the end

                        let deg;
                        if (seg === 0) {
                            // forward
                            deg = startDeg + (endDeg - startDeg) * eased;
                        } else if (seg === 1) {
                            // back
                            deg = endDeg + (startDeg - endDeg) * eased;
                        } else if (seg === 2) {
                            // forward again
                            deg = startDeg + (endDeg - startDeg) * eased;
                        } else {
                            // back to start at end
                            deg = endDeg + (startDeg - endDeg) * eased;
                        }

                        const rad = ((deg - 90) * Math.PI) / 180;
                        const x = Math.cos(rad) * R1;
                        const y = Math.sin(rad) * R1;
                        hintHand.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;

                        if (p < 0.999 && hintRunning) {
                            hintRafId = requestAnimationFrame(frame);
                        } else {
                            hintRunning = false;
                            // Snap to the true final position (startDeg) and fade without moving
                            (function positionAt(deg) {
                                const rad0 = ((deg - 90) * Math.PI) / 180;
                                const x0 = Math.cos(rad0) * R1;
                                const y0 = Math.sin(rad0) * R1;
                                hintHand.style.transform = `translate(-50%, -50%) translate(${x0}px, ${y0}px)`;
                            })(startDeg);
                            setTimeout(() => {
                                hintHand.classList.remove("visible");
                                // After fade out, wait 3s then start again if not interacted
                                setTimeout(() => {
                                    if (hintLoopActive) animateHint();
                                }, hintDelayMs);
                            }, 500);
                        }
                    }

                    hintRafId = requestAnimationFrame(frame);
                }

                // Trigger the hint only when the controller is in view (4 passes total)
                function scheduleHintWhenVisible() {
                    const trigger = () => {
                        // Small delay to allow layout settle
                        setTimeout(() => {
                            if (!hintRunning) animateHint();
                        }, 150);
                    };
                    if ("IntersectionObserver" in window) {
                        const io = new IntersectionObserver(
                            (entries) => {
                                for (const entry of entries) {
                                    if (
                                        entry.isIntersecting &&
                                        entry.intersectionRatio >= 0.6
                                    ) {
                                        io.disconnect();
                                        trigger();
                                        break;
                                    }
                                }
                            },
                            { threshold: [0.6] },
                        );
                        io.observe(wrapper);
                    } else {
                        const onScrollCheck = () => {
                            const rect = wrapper.getBoundingClientRect();
                            const vh =
                                window.innerHeight ||
                                document.documentElement.clientHeight;
                            const visible =
                                rect.top < vh * 0.8 && rect.bottom > vh * 0.2;
                            if (visible) {
                                window.removeEventListener(
                                    "scroll",
                                    onScrollCheck,
                                );
                                trigger();
                            }
                        };
                        window.addEventListener("scroll", onScrollCheck, {
                            passive: true,
                        });
                        // initial check in case it's already in view
                        onScrollCheck();
                    }
                }
                scheduleHintWhenVisible();
            });
        </script>
    </head>
    <body>
        <div class="section">
            <div class="snr-figure-container">
                <img
                    src="SNR_experiment/SNR_figure.png"
                    alt="SNR Figure"
                    class="snr-figure"
                />
                <div class="gif-overlay">
                    <img
                        src="SNR_experiment/speckle_vibration_fast_level_1.gif"
                        alt="Speckle Vibration"
                        class="gif-profile"
                        id="speckleGif"
                    />
                </div>
            </div>

            <div class="controller-row">
                <div class="volume-control" aria-hidden="false">
                    <div
                        class="rotary-wrapper"
                        id="volumeKnob"
                        role="slider"
                        aria-label="Speaker volume"
                        aria-valuemin="0"
                        aria-valuemax="11"
                        aria-valuenow="0"
                        tabindex="0"
                    >
                        <div class="ticks"></div>
                        <div class="rotary-knob">
                            <div
                                class="rotary-angle"
                                style="transform: rotate(-120deg)"
                            >
                                <div class="rotary-indicator"></div>
                            </div>
                        </div>
                        <!-- hint hand icon -->
                        <svg
                            class="hint-hand"
                            id="hintHand"
                            viewBox="0 0 64 64"
                            aria-hidden="true"
                        >
                            <path
                                fill="#ffffff"
                                stroke="#bbb"
                                d="M20 30v-8a4 4 0 0 1 8 0v8h2v-10a4 4 0 0 1 8 0v10h2v-8a4 4 0 0 1 8 0v16c0 7-5 12-12 12h-6c-7 0-12-5-12-12v-8z"
                            />
                            <circle cx="26" cy="50" r="2" fill="#bbb" />
                        </svg>
                    </div>
                    <div class="volume-readout">
                        <div class="title">Speaker Volume</div>
                        <button
                            class="volume-label"
                            id="volumeLabel"
                            type="button"
                            aria-live="polite"
                        >
                            OFF
                        </button>
                    </div>
                </div>

                <div class="signal-panel">
                    <div class="signal-card">
                        <div class="signal-viewport">
                            <div
                                class="signal-strip"
                                id="signalStrip"
                                style="--scroll-duration: 8s"
                            >
                                <div class="signal-frame">
                                    <img
                                        id="sigImg1"
                                        class="signal-img"
                                        alt="signal A"
                                    />
                                </div>
                                <div class="signal-frame">
                                    <img
                                        id="sigImg2"
                                        class="signal-img"
                                        alt="signal B"
                                    />
                                </div>
                            </div>
                        </div>
                        <div class="signal-footer">
                            <div class="signal-meta" id="signalMeta">
                                SNR: 0 dB
                            </div>
                            <div class="signal-meta">
                                Recovered signal from vibrations
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!--     <div class="section">
        <h2>Acknowledgements</h2>
        <p>This work was supported by the Weizmann Center for New Scientists, the Institute of AI, and the MBZUAI-WIS Joint Program (SB).</p>
    </div> -->
        </div>

        <script>
            // ---------------- File:// SVG scroller wiring ----------------
            const signalStrip = document.getElementById("signalStrip");
            const sigImg1 = document.getElementById("sigImg1");
            const sigImg2 = document.getElementById("sigImg2");
            const metaEl = document.getElementById("signalMeta");

            // ---------------- Vertical discrete slider (6 levels) ----------------
            (function initVerticalSlider() {
                const slider = document.getElementById("vSlider");
                const thumb = document.getElementById("vThumb");
                const water = document.getElementById("vWater");
                const ticksWrap = document.getElementById("vTicks");
                const valueEl = document.getElementById("vValue");
                const hintHand = document.getElementById("vHintHand");
                if (!slider || !thumb || !ticksWrap || !valueEl || !water)
                    return;

                const NUM_LEVELS = 6; // 0..5  {0,20,40,60,80,100}%
                const toPercent = (level) => level * 20; // level index to display percent

                // Build ticks at fixed positions (0..100%) from bottom
                for (let i = 0; i < NUM_LEVELS; i++) {
                    const tick = document.createElement("div");
                    tick.className = "v-tick";
                    const pct = (i / (NUM_LEVELS - 1)) * 100; // 0..100
                    tick.style.bottom = `${pct}%`;
                    ticksWrap.appendChild(tick);
                }

                function setLevel(level) {
                    const clamped = Math.max(
                        0,
                        Math.min(NUM_LEVELS - 1, level),
                    );
                    const pct = (clamped / (NUM_LEVELS - 1)) * 100;
                    thumb.style.bottom = `${pct}%`;
                    valueEl.textContent = `${toPercent(clamped)}%`;
                    slider.setAttribute("aria-valuenow", String(clamped));
                    // Update water height to match track percentage
                    const rect = slider.getBoundingClientRect();
                    const trackTop = 10; // per CSS
                    const trackBottom = 10; // per CSS
                    const trackHeight = rect.height - (trackTop + trackBottom);
                    const waterHeightPx = (pct / 100) * trackHeight;
                    water.style.height = `${waterHeightPx}px`;
                }

                function clientYToLevel(clientY) {
                    const rect = slider.getBoundingClientRect();
                    const trackTop = rect.top + 10; // from CSS .v-track top
                    const trackBottom = rect.bottom - 10; // from CSS .v-track bottom
                    const trackHeight = trackBottom - trackTop;
                    const y = Math.max(
                        trackTop,
                        Math.min(trackBottom, clientY),
                    );
                    const t = 1 - (y - trackTop) / trackHeight; // 0..1 bottom->top
                    const raw = t * (NUM_LEVELS - 1);
                    return raw; // return float for continuous feel
                }

                let dragging = false;
                let currentFloat = 0; // track float while dragging

                // --- Hint loop: show hand moving 0% -> 60% -> 0%, twice, then fade and wait 3s ---
                let vHintLoopActive = true;
                let vHintRunning = false;
                let vHintRafId = 0;

                function positionHintAtPercent(percent) {
                    if (!hintHand) return;
                    const rect = slider.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const bottomPx =
                        10 +
                        (Math.max(0, Math.min(100, percent)) / 100) *
                            trackHeight;
                    hintHand.style.bottom = `${bottomPx}px`;
                }

                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                function animateVHint() {
                    if (!hintHand || !vHintLoopActive) return;
                    if (vHintRunning) return;
                    vHintRunning = true;

                    // Place at 0% before showing
                    positionHintAtPercent(0);
                    hintHand.classList.add("visible");

                    const baseDur = 900; // ms per segment
                    const segments = 4; // up, down, up, down
                    const totalDur = baseDur * segments;
                    const startTime = performance.now();

                    function frame(now) {
                        // stop if disabled mid-animation
                        if (!vHintLoopActive) {
                            vHintRunning = false;
                            hintHand.classList.remove("visible");
                            return;
                        }
                        const p = Math.min(0.999, (now - startTime) / totalDur);
                        const segFloat = p * segments;
                        const seg = Math.floor(segFloat);
                        const localT = segFloat - seg; // 0..1
                        const eased = easeOutCubic(localT);

                        // 0% <-> 60% path
                        let percent;
                        if (seg % 2 === 0) {
                            // forward: 0 -> 60
                            percent = 60 * eased;
                        } else {
                            // back: 60 -> 0
                            percent = 60 * (1 - eased);
                        }
                        positionHintAtPercent(percent);

                        if (p < 0.999 && vHintRunning) {
                            vHintRafId = requestAnimationFrame(frame);
                        } else {
                            // Second loop immediately
                            const start2 = performance.now();
                            function frame2(now2) {
                                if (!vHintLoopActive) {
                                    vHintRunning = false;
                                    hintHand.classList.remove("visible");
                                    return;
                                }
                                const p2 = Math.min(
                                    0.999,
                                    (now2 - start2) / totalDur,
                                );
                                const segFloat2 = p2 * segments;
                                const seg2 = Math.floor(segFloat2);
                                const localT2 = segFloat2 - seg2;
                                const eased2 = easeOutCubic(localT2);
                                let percent2;
                                if (seg2 % 2 === 0) {
                                    percent2 = 60 * eased2;
                                } else {
                                    percent2 = 60 * (1 - eased2);
                                }
                                positionHintAtPercent(percent2);
                                if (p2 < 0.999) {
                                    vHintRafId = requestAnimationFrame(frame2);
                                } else {
                                    // Snap to 0%, fade out, then wait 3s and restart
                                    positionHintAtPercent(0);
                                    vHintRunning = false;
                                    setTimeout(() => {
                                        hintHand.classList.remove("visible");
                                        setTimeout(() => {
                                            if (vHintLoopActive) animateVHint();
                                        }, 3000);
                                    }, 50);
                                }
                            }
                            vHintRafId = requestAnimationFrame(frame2);
                        }
                    }
                    vHintRafId = requestAnimationFrame(frame);
                }

                function disableVHint() {
                    vHintLoopActive = false;
                    if (vHintRunning && vHintRafId)
                        cancelAnimationFrame(vHintRafId);
                    vHintRunning = false;
                    hintHand?.classList.remove("visible");
                }

                function onPointerDown(e) {
                    dragging = true;
                    slider.classList.add("dragging");
                    slider.setPointerCapture?.(e.pointerId);
                    currentFloat = clientYToLevel(e.clientY);
                    // live position during drag
                    const pct = (currentFloat / (NUM_LEVELS - 1)) * 100;
                    thumb.style.bottom = `${pct}%`;
                    // Live water update
                    const rect = slider.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const waterHeightPx = (pct / 100) * trackHeight;
                    water.style.height = `${waterHeightPx}px`;
                    e.preventDefault();
                    // stop hint loop on first interaction
                    disableVHint();
                }

                function onPointerMove(e) {
                    if (!dragging) return;
                    currentFloat = clientYToLevel(e.clientY);
                    const pct = (currentFloat / (NUM_LEVELS - 1)) * 100;
                    thumb.style.bottom = `${pct}%`;
                    // Live water update during drag
                    const rect = slider.getBoundingClientRect();
                    const trackHeight = rect.height - 20; // 10 top + 10 bottom
                    const waterHeightPx = (pct / 100) * trackHeight;
                    water.style.height = `${waterHeightPx}px`;
                }

                function onPointerUp(e) {
                    if (!dragging) return;
                    dragging = false;
                    slider.classList.remove("dragging");
                    slider.releasePointerCapture?.(e.pointerId);
                    // snap to nearest discrete level
                    const snapped = Math.round(currentFloat);
                    setLevel(snapped);
                }

                slider.addEventListener("pointerdown", onPointerDown);
                window.addEventListener("pointermove", onPointerMove, {
                    passive: true,
                });
                window.addEventListener("pointerup", onPointerUp);

                // Keyboard: ArrowUp/Down to move between 6 levels
                slider.addEventListener("keydown", (e) => {
                    const now = Number(
                        slider.getAttribute("aria-valuenow") || "0",
                    );
                    if (e.key === "ArrowUp") {
                        setLevel(now + 1);
                        e.preventDefault();
                    } else if (e.key === "ArrowDown") {
                        setLevel(now - 1);
                        e.preventDefault();
                    } else if (e.key === "Home") {
                        setLevel(0);
                        e.preventDefault();
                    } else if (e.key === "End") {
                        setLevel(NUM_LEVELS - 1);
                        e.preventDefault();
                    }
                    disableVHint();
                });

                // Init at 0%
                setLevel(0);
                // Start hint loop after a small delay
                setTimeout(() => {
                    if (hintHand) {
                        positionHintAtPercent(0);
                        animateVHint();
                    }
                }, 400);
            })();

            function getSvgPathForDb(db) {
                // db is integer 0..44 step 4
                return `SNR_experiment/${db}dB.svg`;
            }

            const SNR_BY_DB = {
                0: "-29.18",
                4: "-14.11",
                8: "-6.988",
                12: "-5.517",
                16: "-1.554",
                20: "3.125",
                24: "8.203",
                28: "11.85",
                32: "15.5",
                36: "19.27",
                40: "23.04",
                44: "25.85",
            };

            function setSignalForDb(db) {
                const url = getSvgPathForDb(db);
                sigImg1.src = url;
                sigImg2.src = url;
                const mapped = SNR_BY_DB[db] ?? String(db);
                metaEl.textContent = `SNR: ${mapped} dB`;
            }

            // Speed mapping: higher dB scrolls a bit faster
            function setScrollSpeedForDb(db) {
                const base = 10; // seconds
                const speed = Math.max(5, base - db * 0.1); // 0dB ~10s, 44dB ~5.6s
                signalStrip.style.setProperty("--scroll-duration", `${speed}s`);
            }

            function updateSignalFromLevel(levelIndex) {
                const db = Math.max(0, Math.min(11, levelIndex)) * 4;
                setSignalForDb(db);
                setScrollSpeedForDb(db);
            }

            // Initial signal (OFF -> 0 dB)
            setSignalForDb(0);
            setScrollSpeedForDb(0);
        </script>
    </body>
</html>
